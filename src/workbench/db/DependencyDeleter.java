/*
 * DependencyDeleter.java
 *
 * This file is part of SQL Workbench/J, http://www.sql-workbench.net
 *
 * Copyright 2002-2007, Thomas Kellerer
 * No part of this code maybe reused without the permission of the author
 *
 * To contact the author please send an email to: support@sql-workbench.net
 *
 */
package workbench.db;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import workbench.db.importer.TableDependencySorter;
import workbench.storage.ColumnData;
import workbench.storage.DmlStatement;
import workbench.storage.SqlLiteralFormatter;

/**
 * A class to create statements to delete all dependent rows for the 
 * given root table.
 * 
 * @author  support@sql-workbench.net
 */
public class DependencyDeleter
{
	private WbConnection connection;
	private TableIdentifier rootTable = null;
	private List<DmlStatement> statements;
	private List<DependencyNode> dependentTables = null;
	private SqlLiteralFormatter formatter;
	
	/**
	 * Define the table and the column values for a specific row to 
	 * 
	 * @param table the table from which rows should be deleted
	 * @throws java.sql.SQLException
	 */
	 
	public DependencyDeleter(WbConnection aConnection, TableIdentifier table)
		throws SQLException
	{
		this.connection = aConnection;
		
		if (table == null) throw new IllegalArgumentException("The table name may not be empty");

		this.rootTable = table.createCopy();
		if (rootTable.getSchema() == null)
		{
			rootTable.setSchema(this.connection.getMetadata().getSchemaToUse());
		}
		this.formatter = new SqlLiteralFormatter(this.connection);
	}

	public CharSequence getDeleteForAll()
	{
		StringBuilder result = new StringBuilder(200);
		for (DependencyNode node : dependentTables)
		{
			result.append("DELETE FROM ");
			result.append(node.getTable().getTableName());
			result.append(";\n");
		}
		result.append("\nCOMMIT;\n");
		return result;
	}

	public void getStatementsForPKvalues(List<ColumnData> values)
	{
		TableDependencySorter sorter = new TableDependencySorter(connection);
		this.dependentTables = sorter.getSortedNodesForDelete(rootTable);
		this.statements = new LinkedList<DmlStatement>();
		
		for (DependencyNode node : dependentTables)
		{
		}

	}

	protected Map<DependencyNode, List<ColumnData>> retrieveFkValues(List<ColumnData> pkValues)
	{
		// Need to retrieve the values in reverse order as the 
		// list generated by the TableDepencySorter puts the 
		// node with the highest level first
		// we don't need to include the last table as that is the root table
		List<DependencyNode> reverseList = new ArrayList<DependencyNode>(this.dependentTables);
		Collections.reverse(reverseList);
		
		Map<DependencyNode, List<ColumnData>> result = new HashMap<DependencyNode, List<ColumnData>>();
		
		for (DependencyNode node : reverseList)
		{
			result.put(node, pkValues);
			
		}
		
		return null;
	}
	
	protected List<ColumnData> retrieveValues(DependencyNode node, List<ColumnData> parentPKValues)
	{
		List<ColumnData> result = new ArrayList<ColumnData>();
		
		StringBuilder sql = new StringBuilder(100);
		Map<String, String> colmapping = node.getColumns();
		
		sql.append("SELECT ");
		boolean first = true;
		for (String col : colmapping.keySet())
		{
			if (first) 
			{
				first = false;
			}
			else
			{
				sql.append(',');
			}
			sql.append(col);
		}
		sql.append("FROM ");
		sql.append(node.getTable().getTableExpression(connection));
		sql.append(" WHERE ");
		
		for (ColumnData data : parentPKValues)
		{
			
		}
		return null;
	}
	
	private Object getColumnValue(String colname, List<ColumnData> values)
	{
		for (ColumnData data : values)
		{
			if (data.getIdentifier().getColumnName().equalsIgnoreCase(colname))
			{
				return data.getValue();
			}
		}
		return null;
	}
}
