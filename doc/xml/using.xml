  <section id="using">
    <title>Using &wb-productname;</title>

    <section id="executing-sql-statements">
      <title>Executing SQL statements</title>

      <section id="statement-history">
      <title>Statement history</title>

      <para>When executing a statement the contents of the editor is put
        into an internal buffer together with the information about the
        text selection and the cursor position. Even when you select a part of the current
        text and execute that statement, the whole text is stored in the history buffer together
        with the selection information. When you select and execute different parts of the text
        and then move through the history you will see the selection change for each history
        entry.</para>
      <para>The previous statement can be
        recalled by pressing <keycap>Alt-Left</keycap> or choosing
      <menuchoice><guimenu>SQL</guimenu><guimenuitem>Previous Statement</guimenuitem></menuchoice>
        statement from the menu. Once the previous statement(s) have been
        recalled the next statement can be shown using <keycap>Alt-Right</keycap> or choosing
      <menuchoice><guimenu>SQL</guimenu><guimenuitem>Next Statement</guimenuitem></menuchoice>
        from the menu. This is similar to browsing through the history of a web browser.</para>
      </section>

      <section id="execute-sql-commands">
      <title>Executing Statements</title>
      <para>There are three different ways to execute a SQL command</para>

      <para><emphasis role="bold">Execute the selected text</emphasis></para>
      <para>When you press <keycap>Ctrl-E</keycap> or select
      <menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute selected</guimenuitem></menuchoice>
				 the currently selected text will be send to the DBMS for execution. If no text is
				 selected the complete contents of the editor will be send to the database.
      </para>

      <para><emphasis role="bold">Execute current command</emphasis></para>
      <para>When you press <keycap>Ctrl-Enter</keycap> or select
      <menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute current</guimenuitem></menuchoice>
				 the current statement will be executed. The "current" statement will be the text
				 between the next delimiter before the current cursor position and the delimiter
				 after the cursor position.</para>
      <para>Example (| indicating the cursor position)</para>
      <programlisting>SELECT firstname, lastname FROM person;

DELETE FROM person| WHERE lastname = 'Dent';
COMMIT;</programlisting>
      <para>When pressing Ctrl-Enter the <literal>DELETE</literal> statement will be exectuted</para>
      <para>You can configure &wb-productname; to automatically jump to the next statement,
         after executing the current statement. Simply select <menuchoice><guimenu>SQL</guimenu><guimenuitem>Jump to next statement</guimenuitem></menuchoice>
         The check mark next to the menu item indicates if this option is enabled.
      </para>
      <para><emphasis role="bold">Execute All</emphasis></para>
      <para>If you want to execute the complete text in the editor regardless
				 of the current selection, use the <guimenuitem>Execute all</guimenuitem> command.
				 Either by pressing <keycap>Ctrl-Shift-E</keycap> or selecting
      <menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute All</guimenuitem></menuchoice>
      </para>

      <para>As long as at least one statement is running the title of the main window
				 will be prefixed with the &raquo; sign. Even if the main window is minimized
				 you can still see if a statement is running by looking at the window title.</para>
         
      <para>You can use variables in your SQL statements that are replaced when 
         the statement is executed. Details on how to use variables can be found in
         the chapter <xref linkend="using-variables"/>.</para>
      </section>

      <section id="execute-dml">
      <title>Executing DML Statements</title>

      <para>SQL statements can be entered in the upper part of the window.
        Please refer to <xref linkend="editor"/> for details on the editing features
        of &wb-productname;.</para>
      <para>
        The tabbed display allows you to keep more than one statement
        accessible (without needing to use the history functions). Each tab
        has its own result set and message panel. When you switch to a
        different statement tab, the result list in the lower part of the
        window will change to either the last result or the last message of
        that statement.</para>

      <para>For JDBC drivers which do not support multi-threaded execution (e.g. Oracle's
				JDBC driver), you can configure your <link linkend="profiles">Connection Profile</link>
				so that &wb-productname; will open a new connection for each tab.</para>

      <para>If you enter more than one statement in the editor and want to execute all statements
        as a batch script, you need to delimit each statement. The SQL standard for terminating a SQL
        statement is the semicolon. Alternatively you can separate each statement with the keyword
      <literal>GO</literal> on a single line (MS SQL Server Syntax).</para>
      <para>As a third alternative, an <link linkend="options-alternate-delimiter">alternate delimiter</link>
        can be defined, which can be used in cases where the semicolon is not suitable. See <xref linkend="execute-ddl"/>
        for details.
      </para>

      <para>Valid "scripts" are:</para>
      <programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox';
COMMIT;</programlisting>
      <para>or using the keyword <literal>GO</literal>. This is the same syntax as the MS SQL Query Analyzer uses</para>
      <programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox'
GO
COMMIT
GO</programlisting>
      <para>or if the alternate delimiter has been set to / the same syntax as Oracle's
SQL*Plus can be used.</para>
      <programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox'
/
COMMIT
/</programlisting>
      <para>The detection of the MS SQL "<literal>GO</literal>" syntax only works if the script
				that is to be executed is terminated with a <literal>GO</literal> on a single line. The
				following script will fail on every database that does not know the GO keyword (to my
				knowledge MS SQL Server is the only one supporting this):</para>
      <programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox'
GO
COMMIT</programlisting>
      <para>As the complete script does <emphasis role="bold">not</emphasis> end with the
      <literal>GO</literal> keyword, it is not recognized by &wb-productname;. In this case
				the whole script will be send to the server because no (known) delimiter is used
				at all.</para>

      <note><para>This automatic detection of the delimiter does not work when using
				the <link linkend="command-wbinclude">WbInclude</link> command with large files
				that are not processed in memory.</para></note>
				
      <para>You can run any statement that is valid for the current DBMS. If
        the statement returns a result set, it will be displayed, otherwise
        any messages from the server will be displayed in the messages tab. To
        add or remove editor pages, right click on the tab header and choose
      <guimenuitem>Add tab</guimenuitem> or <guimenuitem>Close tab</guimenuitem>).
				You can re-order the tabs by right clicking on the tab label, then 
				choose <guimenuitem>Move left</guimenuitem> or <guimenuitem>Move right</guimenuitem>
				to change the position of the tab.
			</para>


      <para>A statement is executed by either pressing <keycap>F9</keycap>, <keycap>Ctrl-E</keycap> or
        clicking the <literal>Execute Selected</literal> button
      <guiicon><inlinegraphic fileref="@IMAGE_DIR@/ExecuteSel16.gif" format="GIF"/></guiicon>
				in the toolbar. This will execute the currently selected
        text. If no text is selected in the editor, the complete statement
        will be executed. If you want to execute the whole statement even when
        text is selected, use the command
      <menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute All</guimenuitem></menuchoice>
      </para>

      <para>To execute the statement in which the cursor is currently
        located use <keycap>Ctrl-Enter</keycap>. The current statement is defined as the text
        between the previous SQL delimiter and the next SQL delimiter. The
        delimiter is not necessarily a semicolon. The delimiter can
        be configured in the <link linkend="options">system preferences</link>.
      </para>

      <para>The font that is used for the SQL editor can be defined in the
      <link linkend="options">system preferences</link>.</para>
      </section>

      <section id="execute-ddl" xreflabel="Executing DDL Statements">
      <title>Executing DDL Statements</title>

      <para>&wb-productname; will send every statement to the backend DBMS, so
        executing DDL statements (<literal>CREATE TABLE</literal>, ...) is not a problem.</para>

      <para>However when executing statements such as <literal>CREATE PROCEDURE</literal> which
        in turn contain valid SQL statement, delimited with a ; the &wb-productname;
				will send everything up to the first semicolon to the
        backend. In case of a <literal>CREATE PROCEDURE</literal> statement this will obviously
        result in an error as the statement is not complete.</para>

      <para>This is an example of a <literal>CREATE PROCEDURE</literal> which will
      <emphasis role="bold">not</emphasis> work due to the embedded semicolon in
        the procedure source itself</para>
      <programlisting>CREATE OR REPLACE FUNCTION proc_sample RETURN INTEGER
IS
result INTEGER;
BEGIN
  SELECT max(col1) INTO result FROM sometable;
  RETURN result;
END;</programlisting>
      <para>When executing this script, Oracle would return an error because &wb-productname; will
        send everything up to the keyword <literal>INTEGER</literal> to the database. Obviously this
        fragment is not correct.</para>

      <para>The solution is to terminate the script with a character
        sequence called "<xref linkend="options-alternate-delimiter"/>".
        The value of this sequence can be configured in the <link linkend="options">options dialog</link>.
        The default is <emphasis role="bold">./</emphasis> (a dot followed by a slash)</para>

      <para>If a SQL statement is terminated with the alternate delimiter,
        that delimiter is used instead of a semicolon. This way the semicolons embedded in
        the <literal>CREATE PROCEDURE</literal> script will be sent correctly to the backend
        DBMS.</para>

      <para>So the solution to the above problem is the following script:</para>
      <programlisting>CREATE OR REPLACE FUNCTION proc_sample RETURN INTEGER
IS
result INTEGER;
BEGIN
  SELECT max(col1) INTO result FROM sometable;
  RETURN result;
END;
./</programlisting>
      <para>Note the trailing <literal>./</literal> at the end in order to "turn on" the
        use of the alternate delimiter.</para>

      <para id="alternate-delimiter-usage"><emphasis role="bold">When is the alternate delimiter used?</emphasis></para>

      <para>As soon as the statement (or script) that you execute is terminated with the
        alternate delimiter, the alternate delimiter is used to separate the individual
        SQL statements. When you execute selected text from the editor, be sure to
        select the alternate delimiter as well, otherwise it will not be
        recognized (if the alternate delimiter is not selected, the statement to be executed
        does not end with the alternate delimiter).</para>
      <para>If you use the alternate delimiter (by terminating the whole script with it), then
      <emphasis role="bold">all</emphasis> statements have to be delimited with it. You cannot mix the use
        of the normal semicolon and the alternate delimiter for one execution. The following statement (when executed
        as a whole) would produce an error message:</para>
      <programlisting>
SELECT sysdate FROM DUAL;

CREATE OR REPLACE FUNCTION proc_sample RETURN INTEGER
IS
result INTEGER;
BEGIN
  SELECT max(col1) INTO result FROM sometable;
  RETURN result;
END;
./</programlisting>
        <para>&wb-productname; will use the alternate delimiter because the whole script is terminated
        with it. But as there is a semicolon between the <literal>SELECT</literal> and the <literal>CREATE</literal>
        statement, the whole script will be seen as one statement and it will be sent to the database
        as one statement (which of course will lead to an error).
        </para>
      </section>
    </section>
    
    <section id="blob-support">
      <title>Writing BLOB and CLOB columns</title>
      <para>&wb-productname; supports reading and writing <literal>BLOB</literal> (Binary Large OBject)
        or <literal>CLOB</literal> (Character Large OBject) columns from and to external files. 
        BLOB clumns are sometimes also referred to as binary data. CLOB columns 
        are sometimes also referred to as <literal>LONG VARCHAR</literal>. The exact data type 
        depends on the DBMS used</para>
      <para>To insert and update LOB columns the usual <literal>INSERT</literal> and
        <literal>UPDATE</literal> statements can be used by using a special
        placeholder to define the source for the LOB data. When updating the 
        LOB column, a different placeholder for BLOB and CLOB columns has to be used as
        the process of reading and sending the data is different for binary and character
        data.
      </para>
      <note>
        <para>Only the Oracle 10g driver supports the standard JDBC calls used by &wb-productname; 
        to read and write the LOB data. Earlier drivers will not work as described in this chapter. 
        </para>
      </note>
      
      <section>
         <title>Updating binary data</title>
         <para>To update a BLOB (or binary) column, use the placeholder 
         <literal>{$blobfile=path_to_file}</literal> in the place where the 
         actual value has to occur in the <literal>INSERT</literal> or <literal>UPDATE</literal>
         statement:
         </para>
         <programlisting>UPDATE theTable SET blob_col = {$blobfile=c:/data/image.bmp} WHERE id=24;</programlisting>
         <para>
           &wb-productname; will rewrite the UPDATE statement and send the contents
          of the file located in <literal>c:/data/image.bmp</literal> to the database. The syntax
          for inserting BLOB data is similar. Note that some DBMS might not allow you to 
          supply a value for the blob column during an insert. In this case you need to 
          first insert the row without the blob column, then use an <literal>UPDATE</literal>
          to send the blob data. You should make sure to update only one row by specifying an
          approriate <literal>WHERE</literal> clause.
         </para>
         <programlisting>INSERT INTO theTable (id, blob_col) VALUES (42,{$blobfile=c:/data/image.bmp});</programlisting>
         <para>This will create a new record with id=42 and the content of <literal>c:/data/image.bmp</literal> in 
         the column <literal>blob_col</literal></para>
      </section>
      <section>
          <title>Updating character data</title>
          <para>
            The process of updating or inserting <literal>CLOB</literal> data is identical to the 
            process for <literal>BLOB</literal> data. The only difference is in the syntax of 
            the placeholder used to specify the source file. Firstly, the placeholder has
            to start with <literal>{$clobfile=</literal> and can optionally contain an 
            encoding
          </para>
         <programlisting>UPDATE theTable SET clob_col = {$clobfile=c:/data/image.html encoding=utf8} WHERE id=42;</programlisting>
         <para>If you ommit the encoding parameter, &wb-productname; will leave the data conversion 
         to the JDBC driver (technically, it will use the <literal>PreapredStatement.setAsciiStream()</literal> method
         whereas with an encoding it will use the <literal>PreparedStatement.setCharacterStream()</literal> method).
         </para>
      </section>
    </section>

    <section id="read-blob">
      <title>Saving BLOB data to a file</title>
      <para>
        To save the data stored in a BLOB column, the command <link linkend="command-selectblob">WbSelectBlob</link>
        can be used. The syntax of this command is similar to the regular <literal>SELECT</literal> command
        except that a target file has to be specified where the read data should be stored. 
      </para>
    </section>
    
    <section id="sql-performance">
      <title>Performance tuning when executing SQL</title>
      <para>There are some configuration settings that affect the performance
        of your SQL statements. On slow computers it is recommended to turn off
        the usage of the <link linkend="option-animated-icon">animated icon</link> 
        as the indicator when a statement is running. When running large imports, 
        turning off the animated icon can have a huge impact on the performance.
      </para>
      <para>When running large scripts, the feedback which statement is executed
        can also slow down the execution. It is recommended to either turn off
        the feedback using <link linkend="command-wbfeedback">WBFEEDBACK OFF</link> or by 
        <link linkend="options-consolidate-log">consolidating the script log</link>
      </para>
      <para>When running <link linkend="command-import">imports</link> or 
        <link linkend="command-export">exports</link> it is recommended to turn
        off the progress display in the statusbar that shows the current row
        that is imported/exported because this will slow down the process as 
        well. In both cases you can use <literal>-showprogress</literal>
        to turn off the display. 
      </para>
    </section>

      <section id="macros">
        <title>SQL Macros</title>

        <para>&wb-productname; offers so called SQL macros, or abbreviations.
        You can define macros for often used SQL statements. Once defined, you
        only need to enter the defined macro name and the underlying SQL
        statement will be executed.</para>

        <section id="define-macro">
          <title>Defining Macros</title>

          <para>There are two ways to define a SQL macro.</para>
					<para>If the current statement in the editor should be defined as a macro, select (highlight) the statement's text
					and select  <menuchoice><guimenu>Macros</guimenu><guimenuitem>Add SQL macro</guimenuitem></menuchoice> from the main
          menu. You will be prompted to supply a name for the new macro. If you supply the name of an existing
					macro, the existing macro will be overwritten.</para>
          <para>Alternatively you can add a new macro through
          <menuchoice><guimenu>Macros</guimenu><guimenuitem>Manage Macros...</guimenuitem></menuchoice>.
					This dialog can also be used to delete and and edit existing macros.</para>
          <para>Once a macro is defined, you can execute it by simply typing the
          macro's name in the editor and execute it like any other SQL command.
  				</para>

        </section>

        <section id="exec-macro">
          <title>Executing macros</title>
          <para>To execute a macro, you can either type the alias you have
          defined, or select the macro from the <guimenu>Macros</guimenu> menu.
          The first 10 macros will be listed there directly. To view the complete list of
					macros select <menuchoice><guimenu>Macros</guimenu><guimenuitem>Manage Macros...</guimenuitem></menuchoice>
					After selecting a macro, it can be executed by clicking on the Run <guiicon><inlinegraphic fileref="@IMAGE_DIR@/ExecuteSel16.gif" format="GIF"/></guiicon> button. If you check the
					option "Replace current SQL", then the text in the editor will be replaced with the
					text from the macro when you click on the run button.</para>
        </section>
      </section>

      <section id="using-workspaces">
        <title>Using workspaces</title>

        <para>The complete history for all editor tabs is saved and loaded
        into one file, called a workspace. These workspaces can be saved and loaded
        to restore a specific editing context.
        You can assign a saved workspace to a <link linkend="profiles">connection profile</link>.
        When the connection is established, the workspace is loaded into &wb-productname;. Using this feature
        you can maintain a completely different set of statements for different connections.</para>

        <para>If you do not assign a workspace to a connection profile, a workspace with the
        name <filename>Default.wksp</filename> will be used for storing the statement history.
        This default workspace is shared between <emphasis role="bold">all</emphasis> profiles
        that have no workspace assigned.
        </para>

        <para>To save a new workspace from the current SQL statement history,
        select <menuchoice><guimenu>Workspace</guimenu><guimenuitem>Save Workspace as....</guimenuitem></menuchoice></para>
        <para>The default file extension for workspaces is <filename>wksp</filename>.</para>

        <para>Once you have loaded a workspace, you can save it with
        <menuchoice><guimenu>Workspace</guimenu><guimenuitem>Save Workspace</guimenuitem></menuchoice>.
        The current workspace is automatically
        saved, when you exit &wb-productname;.</para>

        <para>An existing workspace can be loaded with
        <menuchoice><guimenu>Workspace</guimenu><guimenuitem>Load Workspace</guimenuitem></menuchoice>
        </para>
        <para>If you have an external file open in one of the editor tabs, the filename itself
        will be stored in workspace. When loading the workspace &wb-productname; will try to load
        the external file again. If the file does not exist, the last history entry from the saved
        history for that tab will be displayed.</para>
        <para>The workspace file itself is a normal ZIP file, which contains one file with the
        statement history for each tab. The individual files can be extracted from the workspace
        using your favorite UNZIP tool.</para>

      </section>

    <section id="manage-scripts">
      <title>Saving and loading SQL scripts</title>

      <para>The text from the current editor can be saved to an external file,
      by choosing <menuchoice><guimenu>File</guimenu><guimenuitem>Save</guimenuitem></menuchoice> or
      <menuchoice><guimenu>File</guimenu><guimenuitem>Save as</guimenuitem></menuchoice>. The filename for the
      current editor will be remembered. To close the current file, select <menuchoice><guimenu>File</guimenu><guimenuitem>Discard file</guimenuitem></menuchoice>
      <keycap>(Ctrl-F4)</keycap> or use the context menu on the tab label itself.</para>
      <note>
        <para>Detaching a file from the editor will remove the text from editor as well.
        If you only want to detach the filename from the editor
        but keep the text, then press <keycap>Ctrl-Shift-F4</keycap> or hold down the <keycap>Shift</keycap> key
        while selecting the Discard menu item.</para>
      </note>
      <para>When you load a SQL script and execute the statements, be aware that due to the history management
      in &wb-productname; the content of the external file will be placed into the history buffer. If you load
      large files, this might lead to massive memory consumption. Currently only the <emphasis>number</emphasis> of
      statements put into the history can be controlled, but not the total size of the history itself. This might
      change with a later version.</para>
    </section>

    <section id="server-messages">
      <title>Viewing server messages</title>

      <section>
        <title>MS SQL Server</title>
      <para>For MS SQL Server, any message written with the <literal>PRINT</literal>
      command will be displayed in the <literal>Messages</literal> tab after the
      SQL command has finished. The <literal>PRINT</literal> command is usually
      used in stored procedures for logging purposes, but it can also be used
      as a command on its own:</para>
      <programlisting>PRINT "Deleting records...";
DELETE from my_table WHERE value = 42;
PRINT "Done."</programlisting>
      <para>This will execute the <literal>DELETE</literal>. Once this script has
      finished, the <literal>Messages</literal> tab will contain the text:</para>
      <programlisting>Deleting records...
Done.</programlisting>
      </section>

      <section>
        <title>Oracle</title>
      <para>For Oracle the <literal>DBMS_OUTPUT</literal> package is supported. Support for this
      package can to be turned on manually with the <xref linkend="command-enableout"/> command
      or by default in the <link linkend="options-enable-out">system preferences</link>. If
      this support is not turned on, the messages will not be displayed. This is the same
      as using the <literal>SET SERVEROUTPUT ON</literal> command in SQL*Plus
      </para>
      <para>Any message "printed" with <literal>DBMS_OUTPUT.put_line()</literal> will
      be displayed in the message part after the SQL command has finished. Please
      refer to the Oracle documentation if you want to learn more about the
      <literal>DBMS_OUTPUT</literal> package.</para>

      <programlisting>dbms_output.put_line("The answer is 42");</programlisting>
      <para>Once the command has finished, the following will be displayed in the <literal>Messages</literal>
      tab.</para>
      <programlisting>The answer is 42</programlisting>
      </section>

      <section>
        <title>PostgreSQL</title>
      <para>Postgres supports a similar mechanism. Any text returned by a function or
      stored procedure with the <literal>RAISE</literal> keyword, will be displayed in the message tab as well</para>
      </section>

      <section>
        <title>Other database systems</title>
      <para>If your DBMS supports something similar please let me know, and I
      will try to implement it - provided I have access to the DBMS. Please send your
      request to <ulink url="mailto:support@sql-workbench.net">support@sql-workbench.net</ulink></para>
      </section>
    </section>

    <section id="edit-data">
      <title>Editing the data</title>

      <para>Once the data has been retrieved from the database, it can be
      edited directly in the table. The &wb-productname; assumes that enough
      columns have been retrieved from the table so that at a unique
      identifier is available to identify the rows to be updated.</para>

      <para>If you have defined primary keys in your database schema, and they
      are part of the result set, the primary key columns will be used for the
      where statements for <literal>UPDATE</literal> and <literal>DELETE</literal>. If no primary key columns are
      found, the JDBC driver is asked for a <emphasis>best row identifier</emphasis>. If
      that doesn&#39;t return any information, the original values of all
      columns in the result set will be used to restrict <literal>DELETE</literal>&#39;s and
      <literal>UPDATE</literal>&#39;s</para>
      
      <para>After a <literal>SELECT</literal> statement has finished, &wb-productname; analyzes
      the SQL statement and tries to find out which tables are part of the result.
      If only one table was used in the <literal>FROM</literal> list, the primary key
      definition for that table is automatically retrieved from the server. On slow
      network connections (or databases) this can take some time. If you don't need the automatic
      retrieval, you can turn it off in the <link linkend="profile-ignore-disable-auto-edit">
      connection profile</link>.
      </para>
      <para>
      The adavantage of the automatic check is, that you do not need to enter the
      edit mode manually. As soon as you start editing the data, &wb-productname; will
      automatically start the edit mode (if a single update table could be found)
      </para>

      <para>To enter the Edit mode, choose
      <menuchoice><guimenu>Data</guimenu><guimenuitem>Enable Data Edit</guimenuitem></menuchoice>
      from the main menu. The toolbar icon will indicate the edit mode by
      being pressed down (The pressed down look is dependent on the
      Look &#38; Feel).</para>
      <para>Now the data in the result set can be edited. To insert a new row choose
      <menuchoice><guimenu>Data</guimenu><guimenuitem>Insert row</guimenuitem></menuchoice>. The new row will be
      inserted prior the current row. To delete the current row, choose
      <menuchoice><guimenu>Data</guimenu><guimenuitem>Delete row</guimenuitem></menuchoice>.
      To create a copy of the currently selected row choose
      <menuchoice><guimenu>Data</guimenu><guimenuitem>Copy row</guimenuitem></menuchoice>
      </para>

      <para>The changes will not be saved to the database until you choose
      <menuchoice><guimenu>Data</guimenu><guimenuitem>Save</guimenuitem></menuchoice>.
      If the update is successful (no database errors) a <literal>COMMIT</literal> will be
      sent to the database automatically. If an error is reported during the
      update, a <literal>ROLLBACK</literal> will be sent to the database</para>

			<note><para>When you save changes from the result set, &wb-productname; will
			always send a <literal>ROLLBACK</literal> or <literal>COMMIT</literal> to the database server
			regardless of the autocommit setting of the connection profile.</para></note>

      <para>Once you issue a new <literal>SELECT</literal> statement the edit mode will be
      turned off again. If you try to enable the edit mode for a result set where more
      than one table is involved, you will be prompted for the table that should
      be updated.</para>
      
      <para>When editing, &wb-productname; highlights columns that are defined as <literal>NOT NULL</literal>
      in the database. You can turn this feature off, or change the color used by editing the
      <link linkend="settings-highlight-notnull">configuration file</link>.
      </para>
    </section>
    
    <section id="using-copy-clipboard">
        <title>Copying result data to the clipboard</title>
        <para>Once you have retrieved data and it is displayed in the result set table,
            you can copy the data to the clipboard in various formats. These are the same
            formats available when exporting data using the <link linkend="command-export">WbExport</link>
            command.
        </para>
        <para>Cou can either copy all the data, or only selected rows to the clipboard. 
            When you select the menu item while holding down the <keycap>Control</keycap> key
            you will be able to select the columns that should be part of the data to be copied.
        </para>
    </section>
    
    <section id="filter-data">
      <title>Filtering the result</title>
      <para>Once the data has been retrieved from the Server it can be filtered
      with the need to re-retrieve the data.</para>
      <para>
      To define a filter, click on the <literal>Filter</literal> <guiicon><inlinegraphic fileref="@IMAGE_DIR@/filter16.gif" format="GIF"/></guiicon>
      button in the toolbar or select <menuchoice><guimenu>Data</guimenu><guimenuitem>Filter data</guimenuitem></menuchoice>.
      A dialog will appear where you can define a filter for the current result set. Each line
      in the filter dialog defines an expression that will be applied to the column selected
      in the first dropdown. 
      </para>
      <para>
        To add a multi-column expression, press the <literal>More</literal> button, to create
        a new line. To remove a column expression from the filter, click the <literal>Remove</literal> 
        <guiicon><inlinegraphic fileref="@IMAGE_DIR@/Remove16.gif" format="GIF"/></guiicon> icon.
        For character based column data, you can select to ignore the case of the column's data
        when applying the expression, i.e. when <literal>Ignore case</literal> is selected, the
        expression <literal>'NAME = arthur'</literal> will match the column value '<literal>Arthur</literal>', 
        and '<literal>ARTHUR</literal>'.
      </para>
      <para>
        By default, the column expressions are combined with an <literal>OR</literal>, i.e. 
        that a row will be displayed if at least one of the column expressions evaluates 
        to true. If you want to view only rows where <emphasis role="bold">all</emphasis>
        column expressions must match, select the <literal>AND</literal> radio button
        at the top of the dialog.
      </para>
    </section>
    
    <!--
    <section id="change-display">
      <title>Changing the display of the result set table</title>

      <para>You may change the width of each column. When you
      press the right mouse button in the header area of the result set, the
      following menu is displayed:</para>

      <para><guimenuitem>Optimal width</guimenuitem> determines the text width of the longest
      entry of that column and adjusts the column width to completely display
      the contents. Optimal width for all columns can also be executed by
      pressing Ctrl-W</para>

      <para>Each row can be resized vertically as well, to display multi line
      contents.</para>
    </section>
    -->

  </section>
