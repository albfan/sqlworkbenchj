<section id="using">
	<title>Using &wb-productname;</title>
	
	<section id="executing-sql-statements">
		<title>Executing SQL statements</title>

		<section id="statement-history">
			<title>Statement history</title>

			<para>When executing a statement the contents of the editor is put
			into an internal buffer together with the information about the
			text selection and the cursor position. Even when you select a part of the current
			text and execute that statement, the whole text is stored in the history buffer together
			with the selection information. When you select and execute different parts of the text
			and then move through the history you will see the selection change for each history
			entry.</para>
			<para>The previous statement can be
			recalled by pressing <keycap>Alt-Left</keycap> or choosing
			<menuchoice><guimenu>SQL</guimenu><guimenuitem>Previous Statement</guimenuitem></menuchoice>
			statement from the menu. Once the previous statement(s) have been
			recalled the next statement can be shown using <keycap>Alt-Right</keycap> or choosing
			<menuchoice><guimenu>SQL</guimenu><guimenuitem>Next Statement</guimenuitem></menuchoice>
			from the menu. This is similar to browsing through the history of a web browser.</para>
			<para>
				You can clear the statement history for the current tab, but selecting
				<menuchoice><guimenu>SQL</guimenu><guimenuitem>Clear history</guimenuitem></menuchoice>
			</para>
			<note>
				When you clear the content of the editor (e.g. by selecting the whole text 
				and then pressing the <keycap>Del</keycap> key) this will not clear the statement
				history. When you load the associated workspace the next time, the editor will 
				automatically display the last statement from the history. You need to manually
				clear the statement history, if you want an empty editor the next time you 
				load the workspace.
			</note>
		</section>

		<section id="execute-sql-commands">
			<title>Executing Statements</title>
			<para>There are three different ways to execute a SQL command</para>

			<para><emphasis role="bold">Execute the selected text</emphasis></para>
			<para>When you press <keycap>Ctrl-E</keycap> or select
				<menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute selected</guimenuitem></menuchoice>
				the currently selected text will be send to the DBMS for execution. If no text is
				selected the complete contents of the editor will be send to the database.
			</para>

			<para id="execute-current"><emphasis role="bold">Execute current statement</emphasis></para>
			<para>When you press <keycap>Ctrl-Enter</keycap> or select
			<menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute current</guimenuitem></menuchoice>
			the current statement will be executed. The "current" statement will be the text
			between the next delimiter before the current cursor position and the delimiter
			after the cursor position.</para>
			<para>Example (| indicating the cursor position)</para>
			<programlisting>SELECT firstname, lastname FROM person;

DELETE FROM person| WHERE lastname = 'Dent';
COMMIT;</programlisting>
			<para>When pressing Ctrl-Enter the <literal>DELETE</literal> statement will be exectuted</para>
			<para>You can configure &wb-productname; to automatically jump to the next statement,
				after executing the current statement. Simply select <menuchoice><guimenu>SQL</guimenu><guimenuitem>Jump to next statement</guimenuitem></menuchoice>
				The check mark next to the menu item indicates if this option is enabled.
				This option can also be changed through the <link linkend="options-autojump-statement">Options dialog</link>
			</para>
			<para><emphasis role="bold">Execute All</emphasis></para>
			<para>If you want to execute the complete text in the editor regardless
				of the current selection, use the <guimenuitem>Execute all</guimenuitem> command.
				Either by pressing <keycap>Ctrl-Shift-E</keycap> or selecting
				<menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute All</guimenuitem></menuchoice>
			</para>

			<para>As long as at least one statement is running the title of the main window
			will be prefixed with the &raquo; sign. Even if the main window is minimized
			you can still see if a statement is running by looking at the window title.</para>
         
			<para>You can use variables in your SQL statements that are replaced when 
			the statement is executed. Details on how to use variables can be found in
			the chapter <xref linkend="using-variables"/>.</para>
		</section>

		<section id="display-result">
			<title>Displaying results</title>
			<para>
				When you run SQL statements that produce a result (such as a <literal>SELECT</literal> 
				statement) these results will be displayed in the lower pane of the window, next to 
				the message panel. For each result that is returned from the server, one tab 
				(labeled "Result") will be created. If you select and execute three <literal>SELECT</literal>
				statements, the lower pane will show three result tabs and the message tab. If your 
				statement(s) did not produce any result, only the messages tab will be displayed.
			</para>
		</section>
		<section id="execute-dml">
			<title>Executing DML Statements</title>

			<para>SQL statements can be entered in the upper part of the window.
			Please refer to <xref linkend="editor"/> for details on the editing features
			of &wb-productname;.</para>
			<para>
			The tabbed display allows you to keep more than one statement
			accessible (without needing to use the history functions). Each tab
			has its own result set and message panel. When you switch to a
			different statement tab, the result list in the lower part of the
			window will change to either the last result or the last message of
			that statement.</para>

			<para>For JDBC drivers which do not support multi-threaded execution (e.g. Oracle's
			JDBC driver), you can configure your <link linkend="profiles">Connection Profile</link>
			so that &wb-productname; will open a new connection for each tab.</para>

			<para>If you enter more than one statement in the editor and want to execute all statements
			as a batch script, you need to delimit each statement. The SQL standard for terminating a SQL
			statement is the semicolon. Alternatively you can separate each statement with the keyword
			<literal>GO</literal> on a single line (MS SQL Server Syntax).</para>
			<para>As a third alternative, an <link linkend="options-alternate-delimiter">alternate delimiter</link>
				can be defined, which can be used in cases where the semicolon is not suitable. See <xref linkend="execute-ddl"/>
				for details.
			</para>

			<para>Valid "scripts" are:</para>
			<programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox';
COMMIT;</programlisting>
			<para>or using the keyword <literal>GO</literal>. This is the same syntax as the MS SQL Query Analyzer uses</para>
			<programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox'
GO
COMMIT
GO</programlisting>
			<para>or if the alternate delimiter has been set to / the same syntax as Oracle's
			SQL*Plus can be used.</para>
			<programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox'
/
COMMIT
/</programlisting>
			<para>The detection of the MS SQL "<literal>GO</literal>" syntax only works if the script
			that is to be executed is terminated with a <literal>GO</literal> on a single line. The
			following script will fail on every database that does not know the GO keyword (to my
			knowledge MS SQL Server is the only one supporting this):</para>
			<programlisting>UPDATE person SET numheads = 2 WHERE name='Beeblebrox'
GO
COMMIT</programlisting>
			<para>As the complete script does <emphasis role="bold">not</emphasis> end with the
			<literal>GO</literal> keyword, it is not recognized by &wb-productname;. In this case
			the whole script will be send to the server because no (known) delimiter is used
			at all.</para>

			<note><para>This automatic detection of the delimiter does not work when using
			the <link linkend="command-wbinclude">WbInclude</link> command with large files
			that are not processed in memory.</para></note>
				
			<para>You can run any statement that is valid for the current DBMS. If
				the statement returns a result set, it will be displayed, otherwise
				any messages from the server will be displayed in the messages tab. To
				add or remove editor pages, right click on the tab header and choose
				<guimenuitem>Add tab</guimenuitem> or <guimenuitem>Close tab</guimenuitem>).
				You can re-order the tabs by right clicking on the tab label, then 
				choose <guimenuitem>Move left</guimenuitem> or <guimenuitem>Move right</guimenuitem>
				to change the position of the tab.
			</para>


			<para>A statement is executed by either pressing <keycap>F9</keycap>, <keycap>Ctrl-E</keycap> or
				clicking the <literal>Execute Selected</literal> button 
				(<guiicon><inlinegraphic fileref="@IMAGE_DIR@/ExecuteSel16.gif" format="GIF"/></guiicon>)
				in the toolbar. This will execute the currently selected
				text. If no text is selected in the editor, the complete statement
				will be executed. If you want to execute the whole statement even when
				text is selected, use the command
				<menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute All</guimenuitem></menuchoice>
			</para>

			<para>To execute the statement in which the cursor is currently
				located use <keycap>Ctrl-Enter</keycap>. The current statement is defined as the text
				between the previous SQL delimiter and the next SQL delimiter. The
				delimiter is not necessarily a semicolon. The delimiter can
				be configured in the <link linkend="options">system preferences</link>.
			</para>

			<para>The font that is used for the SQL editor can be defined in the
			<link linkend="options">system preferences</link>.</para>
		</section>

		<section id="execute-ddl" xreflabel="Executing DDL Statements">
			<title>Executing DDL Statements</title>

			<para>&wb-productname; will send every statement to the backend DBMS, so
			executing DDL statements (<literal>CREATE TABLE</literal>, ...) is not a problem.</para>

			<para>However when executing statements such as <literal>CREATE PROCEDURE</literal> which
			in turn contain valid SQL statement, delimited with a ; the &wb-productname;
			will send everything up to the first semicolon to the
			backend. In case of a <literal>CREATE PROCEDURE</literal> statement this will obviously
			result in an error as the statement is not complete.</para>

			<para>This is an example of a <literal>CREATE PROCEDURE</literal> which will
			<emphasis role="bold">not</emphasis> work due to the embedded semicolon in
			the procedure source itself</para>
			<programlisting>CREATE OR REPLACE FUNCTION proc_sample RETURN INTEGER
IS
result INTEGER;
BEGIN
SELECT max(col1) INTO result FROM sometable;
RETURN result;
END;</programlisting>
			<para>When executing this script, Oracle would return an error because &wb-productname; will
			send everything up to the keyword <literal>INTEGER</literal> to the database. Obviously this
			fragment is not correct.</para>

			<para>The solution is to terminate the script with a character
			sequence called "<xref linkend="options-alternate-delimiter"/>".
			The value of this sequence can be configured in the <link linkend="options">options dialog</link>.
			The default is <emphasis role="bold">./</emphasis> (a dot followed by a slash)</para>

			<para>If a SQL statement is terminated with the alternate delimiter,
			that delimiter is used instead of a semicolon. This way the semicolons embedded in
			the <literal>CREATE PROCEDURE</literal> script will be sent correctly to the backend
			DBMS.</para>

			<para>So the solution to the above problem is the following script:</para>
			<programlisting>CREATE OR REPLACE FUNCTION proc_sample RETURN INTEGER
IS
result INTEGER;
BEGIN
SELECT max(col1) INTO result FROM sometable;
RETURN result;
END;
./</programlisting>
			<para>Note the trailing <literal>./</literal> at the end in order to "turn on" the
			use of the alternate delimiter.</para>

			<para id="alternate-delimiter-usage"><emphasis role="bold">When is the alternate delimiter used?</emphasis></para>

			<para>As soon as the statement (or script) that you execute is terminated with the
			alternate delimiter, the alternate delimiter is used to separate the individual
			SQL statements. When you execute selected text from the editor, be sure to
			select the alternate delimiter as well, otherwise it will not be
			recognized (if the alternate delimiter is not selected, the statement to be executed
			does not end with the alternate delimiter).</para>
			<para>If you use the alternate delimiter (by terminating the whole script with it), then
			<emphasis role="bold">all</emphasis> statements have to be delimited with it. You cannot mix the use
			of the normal semicolon and the alternate delimiter for one execution. The following statement (when executed
			as a whole) would produce an error message:</para>
			<programlisting>SELECT sysdate FROM DUAL;

CREATE OR REPLACE FUNCTION proc_sample RETURN INTEGER
IS
result INTEGER;
BEGIN
SELECT max(col1) INTO result FROM sometable;
RETURN result;
END;
./</programlisting>
			<para>&wb-productname; will use the alternate delimiter because the whole script is terminated
				with it. But as there is a semicolon between the <literal>SELECT</literal> and the <literal>CREATE</literal>
				statement, the whole script will be seen as one statement and it will be sent to the database
				as one statement (which of course will lead to an error).
			</para>
		</section>
	</section>
    
	<section id="blob-support" xreflabel="BLOB support">
			
		<title>Dealing with BLOB and CLOB columns</title>
		<para>&wb-productname; supports reading and writing <literal>BLOB</literal> (Binary Large OBject)
			or <literal>CLOB</literal> (Character Large OBject) columns from and to external files. 
			BLOB clumns are sometimes also referred to as binary data. CLOB columns 
			are sometimes also referred to as <literal>LONG VARCHAR</literal>. The exact data type 
			depends on the DBMS used.
		</para>
			
		<para>To insert and update LOB columns the usual <literal>INSERT</literal> and
			<literal>UPDATE</literal> statements can be used by using a special
			placeholder to define the source for the LOB data. When updating the 
			LOB column, a different placeholder for BLOB and CLOB columns has to be used as
			the process of reading and sending the data is different for binary and character
			data.
		</para>
		<note>
			<para>When working with Oracle, only the 10g driver supports the standard JDBC calls used by &wb-productname; 
				to read and write the LOB data. Earlier drivers will not work as described in this chapter. 
			</para>
		</note>

		<section>
			<title>Updating binary data through SQL</title>
			<para>
				To update a BLOB (or binary) column, use the placeholder 
				<literal>{$blobfile=path_to_file}</literal> in the place where the 
				actual value has to occur in the <literal>INSERT</literal> or <literal>UPDATE</literal>
				statement:
			</para>
			<programlisting>UPDATE theTable SET blob_col = {$blobfile=c:/data/image.bmp} WHERE id=24;</programlisting>
			<para>
				&wb-productname; will rewrite the UPDATE statement and send the contents
				of the file located in <literal>c:/data/image.bmp</literal> to the database. The syntax
				for inserting BLOB data is similar. Note that some DBMS might not allow you to 
				supply a value for the blob column during an insert. In this case you need to 
				first insert the row without the blob column, then use an <literal>UPDATE</literal>
				to send the blob data. You should make sure to update only one row by specifying an
				approriate <literal>WHERE</literal> clause.
			</para>
			<programlisting>INSERT INTO theTable (id, blob_col) VALUES (42,{$blobfile=c:/data/image.bmp});</programlisting>
			<para>
				This will create a new record with id=42 and the content of <literal>c:/data/image.bmp</literal> in 
				the column <literal>blob_col</literal>
			</para>
				
		</section>
			
		<section>
			<title>Updating character data through SQL</title>
			<para>
				The process of updating or inserting <literal>CLOB</literal> data is identical to the 
				process for <literal>BLOB</literal> data. The only difference is in the syntax of 
				the placeholder used to specify the source file. Firstly, the placeholder has
				to start with <literal>{$clobfile=</literal> and can optionally contain 
				a parameter to define the encoding of the source file.
			</para>
			<programlisting>UPDATE theTable SET clob_col = {$clobfile=c:/data/manual.html encoding=utf8} WHERE id=42;</programlisting>
			<para>
				If you ommit the encoding parameter, &wb-productname; will leave the data conversion 
				to the JDBC driver (technically, it will use the <literal>PreapredStatement.setAsciiStream()</literal> method
				whereas with an encoding it will use the <literal>PreparedStatement.setCharacterStream()</literal> method).
			</para>
		</section>

		<section id="read-blob">
			<title>Saving BLOB data to a file using SQL</title>
			<para>
				To save the data stored in a BLOB column, the command <link linkend="command-selectblob">WbSelectBlob</link>
				can be used. The syntax of this command is similar to the regular <literal>SELECT</literal> command
				except that a target file has to be specified where the read data should be stored. 
			</para>
			<note>
				When using the <link linkend="command-export">WbExport</link> command to export
				data, blob data will also be saved into separate files. This works for both 
				export formats (XML and Text).
			</note>
		</section>
			
		<section id="update-blob-editmode">
			<title>BLOB data in the result set</title>
			<para>
				When the result of your <literal>SELECT</literal> query contains BLOB columns, 
				they will be displayed as <literal>(BLOB)</literal>
				together with a button. 
				When you click on the button a dialog will be displayed allowing
				you to save the data to a file, view the data as text (using the selected encoding), 
				display the blob as an image (Windows bitmap files 
				(with the extension <literal>BMP</literal>) is only supported starting with 
				JDK 1.5) or display a hex view of the blob.
			</para>
			<para>
				The window will also let you open the contents of the BLOB data with a predefined
				<link linkend="options-external-tools">external tool</link>. The tools that 
				are defined in the options dialog can be selected from a dropdown. To open 
				the BLOB content with one of the tools, select the tool from the dropdown list,
				then click on the button <guibutton>Open with</guibutton> next to the external
				tools dropdown. &wb-productname; will then retrieve the BLOB data from the server,
				store it in a temporary file on your harddisk, and run the selected application, 
				passing the temporary file as a parameter.
			</para>
			<para>
				From within this information dialog, you can also upload a file to be stored
				in that BLOB column. The file contents will not be sent to the database server
				until you actually save the changes to your result set (this is the same for all 
				changes you make directly in the result set, for details please refer 
				to <xref linkend="edit-data"/>)
			</para>
			<note>
				When using the upload function in the BLOB info dialog, &wb-productname;
				will use the file content for any subsequent display of the binary data or the
				the size information in the information dialog.
				You will need to re-retrieve the data, in order to use
				the blob data from the server. 
			</note>
		</section>
			
	</section>

	<section id="sql-performance">
		<title>Performance tuning when executing SQL</title>
		<para>There are some configuration settings that affect the performance
			of your SQL statements. On slow computers it is recommended to turn off
			the usage of the <link linkend="option-animated-icon">animated icon</link> 
			as the indicator when a statement is running. When running large imports, 
			turning off the animated icon can have a huge impact on the performance.
		</para>
		<para>When running large scripts, the feedback which statement is executed
			can also slow down the execution. It is recommended to either turn off
			the feedback using <link linkend="command-wbfeedback">WBFEEDBACK OFF</link> or by 
			<link linkend="options-consolidate-log">consolidating the script log</link>
		</para>
		<para>When running <link linkend="command-import">imports</link> or 
			<link linkend="command-export">exports</link> it is recommended to turn
			off the progress display in the statusbar that shows the current row
			that is imported/exported because this will slow down the process as 
			well. In both cases you can use <literal>-showprogress</literal>
			to turn off the display (or set it to a high number such as 1000) in 
			order to reduce the overhead caused by updating the screen.
		</para>
	</section>

	<section id="macros">
		<title>SQL Macros</title>

		<para>&wb-productname; offers so called SQL macros, or abbreviations.
		You can define macros for often used SQL statements. Once defined, you
		only need to enter the defined macro name and the underlying SQL
		statement will be executed.</para>

		<section id="define-macro">
			<title>Defining Macros</title>

			<para>There are two ways to define a SQL macro.</para>
			<para>If the current statement in the editor should be defined as a macro, select (highlight) the statement's text
			and select  <menuchoice><guimenu>Macros</guimenu><guimenuitem>Add SQL macro</guimenuitem></menuchoice> from the main
			menu. You will be prompted to supply a name for the new macro. If you supply the name of an existing
			macro, the existing macro will be overwritten.</para>
			<para>Alternatively you can add a new macro through
			<menuchoice><guimenu>Macros</guimenu><guimenuitem>Manage Macros...</guimenuitem></menuchoice>.
			This dialog can also be used to delete and and edit existing macros.</para>
			<para>Once a macro is defined, you can execute it by simply typing the
				macro's name in the editor and execute it like any other SQL command.
			</para>

		</section>

		<section id="exec-macro">
			<title>Executing macros</title>
			<para>
				To execute a macro, you can either type the alias you have
				defined, or select the macro from the <guimenu>Macros</guimenu> menu.
				The first 10 macros will be listed there directly. To view the complete list of
				macros select <menuchoice><guimenu>Macros</guimenu><guimenuitem>Manage Macros...</guimenuitem></menuchoice>
				After selecting a macro, it can be executed by clicking on the Run <guibutton>Run</guibutton> button. If you check the
				option "Replace current SQL", then the text in the editor will be replaced with the
				text from the macro when you click on the run button.
			</para>
			<note>
				Macros will no be evaluated when running in batch mode!
			</note>
		</section>
		<section id="macro-parameters">
			<title>Parameters in macros</title>
			<para>
				Apart from the &wb-productname; <link linkend="using-variables">script variables</link> for SQL Statements, 
				additional "parameters" can be used inside a macro definition. These parameters will be replaced <emphasis>before</emphasis> replacing 
				the script variables.
			</para>
			
			<informaltable frame="all">
				
				<tgroup cols="2" align="left">
						<thead>
							<row>
								<entry>Parameter</entry>
								<entry>Description</entry>
							</row>
						</thead>

						<tbody valign="top">
							<row>
								<entry><para>${selection}$</para></entry>
								<entry>
									<para>
										This parameter will be replaced with the currently selected text. The 
										selected text will not be altered in any way.
									</para>
								</entry>
							</row>
							<row>
								<entry><para>${selected_statement}$</para></entry>
								<entry>
									<para>
										This behaves similar to <literal>${selection}$</literal> except that
										any trailing semicolon will be removed from the selection. Thus the 
										macro definition can always contain the semicolon (e.g. when the 
										macro actually defines a script with multiple statements) but 
										when selecting the text, you do not need to worry whether a semicolon
										is selected or not (and would potentially break the script).
									</para>
								</entry>
							</row>
							<row>
								<entry><para>${current_statement}$</para></entry>
								<entry>
									<para>
										This key will be replaced with the current statement (without the trailing
										delimiter). The current statement is defined by the cursor location
										and is the statement that would be executed when using 
										<link linkend="execute-current"><menuchoice><guimenu>SQL</guimenu><guimenuitem>Execute current</guimenuitem></menuchoice>
										</link>
									</para>
								</entry>
							</row>
							<row>
								<entry><para>${text}$</para></entry>
								<entry>
									<para>
										This key will be replaced with the complete text from the editor (regardless 
										of any selection).
									</para>
								</entry>
							</row>
						</tbody>
				</tgroup>
			</informaltable>

			<para>
				The SQL statement that is eventually executed will be logged into the message panel
				when invoking the macro from the menu. Macros that use the above paramters
				cannot correctly be executed by entering the macro alias in the SQL editor (and 
				then executing the "statement").
			</para>
			
			<note>The parameter keywords are case sensitiv, i.e. 
				the text <literal>${SELECTION}$</literal> will not be replaced!
			</note>
			
			<para>
				This feature can be used to create SQL scripts that work only with 
				with an additional statement. e.g. for Oracle you could define 
				a macro to run an explain plan for the current statement:
				<programlisting>EXPLAIN PLAN FOR 
${current_statement}$
;

COMMIT;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);</programlisting>
				When you run this macro, it will run an <literal>EXPLAIN PLAN</literal>
				for the statement in which the cursor is currently located, and will
				immediately display the results for the explain. Note that the 
				<literal>${current_statement}$</literal> keyword is terminated with 
				a semicolon, as the replacement for <literal>${current_statement}$</literal>
				will never add the semicolon. If you use <literal>${selection}$</literal>
				instead, you have to pay attention to not select the semicolon in the
				editor before running this macro.
			</para>
			<para>
				Another usage of the parameter replacement could be a SQL Statement that
				retrieves the rowcount that would be returned by the current statement:
			</para>
				<programlisting>SELECT count(*) FROM 
(
${current_statement}$
)</programlisting>

		</section>
				
	</section>

	<section id="using-workspaces">
		<title>Using workspaces</title>

		<para>The complete history for all editor tabs is saved and loaded
		into one file, called a workspace. These workspaces can be saved and loaded
		to restore a specific editing context.
		You can assign a saved workspace to a <link linkend="profiles">connection profile</link>.
		When the connection is established, the workspace is loaded into &wb-productname;. Using this feature
		you can maintain a completely different set of statements for different connections.</para>

		<para>If you do not assign a workspace to a connection profile, a workspace with the
			name <filename>Default.wksp</filename> will be used for storing the statement history.
			This default workspace is shared between <emphasis role="bold">all</emphasis> profiles
			that have no workspace assigned.
		</para>

		<para>To save the current SQL statement history and the visible tabs into a new workspace,
		select <menuchoice><guimenu>Workspace</guimenu><guimenuitem>Save Workspace as....</guimenuitem></menuchoice></para>
		<para>The default file extension for workspaces is <filename>wksp</filename>.</para>

		<para>Once you have loaded a workspace, you can save it with
		<menuchoice><guimenu>Workspace</guimenu><guimenuitem>Save Workspace</guimenuitem></menuchoice>.
		The current workspace is automatically
		saved, when you exit &wb-productname;.</para>

		<para>An existing workspace can be loaded with
			<menuchoice><guimenu>Workspace</guimenu><guimenuitem>Load Workspace</guimenuitem></menuchoice>
		</para>
		<para>If you have an external file open in one of the editor tabs, the filename itself
		will be stored in workspace. When loading the workspace &wb-productname; will try to load
		the external file again. If the file does not exist, the last history entry from the saved
		history for that tab will be displayed.</para>
		<para>The workspace file itself is a normal ZIP file, which contains one file with the
		statement history for each tab. The individual files can be extracted from the workspace
		using your favorite UNZIP tool.</para>

	</section>

	<section id="manage-scripts">
		<title>Saving and loading SQL scripts</title>

		<para>The text from the current editor can be saved to an external file,
		by choosing <menuchoice><guimenu>File</guimenu><guimenuitem>Save</guimenuitem></menuchoice> or
		<menuchoice><guimenu>File</guimenu><guimenuitem>Save as</guimenuitem></menuchoice>. The filename for the
		current editor will be remembered. To close the current file, select <menuchoice><guimenu>File</guimenu><guimenuitem>Discard file</guimenuitem></menuchoice>
		<keycap>(Ctrl-F4)</keycap> or use the context menu on the tab label itself.</para>
		<note>
			<para>Detaching a file from the editor will remove the text from editor as well.
			If you only want to detach the filename from the editor
			but keep the text, then press <keycap>Ctrl-Shift-F4</keycap> or hold down the <keycap>Shift</keycap> key
			while selecting the Discard menu item.</para>
		</note>
		<para>When you load a SQL script and execute the statements, be aware that due to the history management
		in &wb-productname; the content of the external file will be placed into the history buffer. If you load
		large files, this might lead to massive memory consumption. Currently only the <emphasis>number</emphasis> of
		statements put into the history can be controlled, but not the total size of the history itself. This might
		change with a later version.</para>
	</section>

	<section id="server-messages">
		<title>Viewing server messages</title>

		<section>
			<title>MS SQL Server</title>
			<para>
				For MS SQL Server, any message written with the <literal>PRINT</literal>
				command will be displayed in the <literal>Messages</literal> tab after the
				SQL command has finished. The <literal>PRINT</literal> command is usually
				used in stored procedures for logging purposes, but it can also be used
				as a command on its own:
			</para>
			<programlisting>PRINT "Deleting records...";
DELETE from my_table WHERE value = 42;
PRINT "Done."</programlisting>
			<para>
				This will execute the <literal>DELETE</literal>. Once this script has
				finished, the <literal>Messages</literal> tab will contain the text:
			</para>
			
			<programlisting>Deleting records...
Done.</programlisting>
		</section>

		<section>
			<title>Oracle</title>
			<para>
				For Oracle the <literal>DBMS_OUTPUT</literal> package is supported. Support for this
				package can to be turned on manually with the <xref linkend="command-enableout"/> command
				or by default in the <link linkend="options-enable-out">system preferences</link>. If
				this support is not turned on, the messages will not be displayed. This is the same
				as using the <literal>SET SERVEROUTPUT ON</literal> command in SQL*Plus
			</para>
			<para>
				Any message "printed" with <literal>DBMS_OUTPUT.put_line()</literal> will
				be displayed in the message part after the SQL command has finished. Please
				refer to the Oracle documentation if you want to learn more about the
				<literal>DBMS_OUTPUT</literal> package.
			</para>

			<programlisting>dbms_output.put_line("The answer is 42");</programlisting>
			<para>
				Once the command has finished, the following will be displayed in the 
				<literal>Messages</literal> tab.
			</para>
			<programlisting>The answer is 42</programlisting>
		</section>

		<section>
			<title>PostgreSQL</title>
			<para>
				Postgres supports a similar mechanism. Any text returned by a function or
				stored procedure with the <literal>RAISE</literal> keyword, will be displayed in the message tab as well
			</para>
		</section>

		<section>
			<title>Other database systems</title>
			<para>
				If your DBMS supports something similar, please let me know. I will try 
				to implement it - provided I have free access to the DBMS. Please send your
				request to <ulink url="mailto:support@sql-workbench.net">support@sql-workbench.net</ulink>
			</para>
		</section>
	</section>

	<section id="edit-data" xreflabel="Editing the data">
		<title>Editing the data</title>

		<para>
			Once the data has been retrieved from the database, it can be
			edited directly in the table. The &wb-productname; assumes that enough
			columns have been retrieved from the table so that at a unique
			identifier is available to identify the rows to be updated.
		</para>

		<para>
			If you have defined primary keys in your database schema, and they
			are part of the result set, the primary key columns will be used for the
			where statements for <literal>UPDATE</literal> and <literal>DELETE</literal>. If no primary key columns are
			found, the JDBC driver is asked for a <emphasis>best row identifier</emphasis>. If
			that doesn&#39;t return any information, the original values of all
			columns in the result set will be used to restrict <literal>DELETE</literal>&#39;s and
			<literal>UPDATE</literal>&#39;s
		</para>
      
		<para>
			After a <literal>SELECT</literal> statement has finished, &wb-productname; analyzes
			the SQL statement and tries to find out which tables are part of the result.
			If only one table was used in the <literal>FROM</literal> list, the primary key
			definition for that table is automatically retrieved from the server. On slow
			network connections (or databases) this can take some time. If you don't need the automatic
			retrieval, you can turn it off in the <link linkend="profile-ignore-disable-auto-edit">
			connection profile</link>.
		</para>
		<para>
			The adavantage of the automatic check is, that you do not need to supply 
			the primary key information for the base table.
			If the automatic check is disabled or if you have more then one table
			in the select list, you will be prompted for the primary key to 
			be used for updating your changes.
		</para>

		<para>To enter the Edit mode, choose
		<menuchoice><guimenu>Data</guimenu><guimenuitem>Enable Data Edit</guimenuitem></menuchoice>
		from the main menu. The toolbar icon will indicate the edit mode by
		being pressed down (The pressed down look is dependent on the
		Look &#38; Feel).</para>
		<para>Now the data in the result set can be edited. To insert a new row choose
			<menuchoice><guimenu>Data</guimenu><guimenuitem>Insert row</guimenuitem></menuchoice>. The new row will be
			inserted prior the current row. To delete the current row, choose
			<menuchoice><guimenu>Data</guimenu><guimenuitem>Delete row</guimenuitem></menuchoice>.
			To create a copy of the currently selected row choose
			<menuchoice><guimenu>Data</guimenu><guimenuitem>Copy row</guimenuitem></menuchoice>
		</para>

		<para>
			The changes will not be saved to the database until you choose
			<menuchoice><guimenu>Data</guimenu><guimenuitem>Save</guimenuitem></menuchoice>.
			If the update is successful (no database errors) a <literal>COMMIT</literal> will be
			sent to the database automatically. If an error is reported during the
			update, a <literal>ROLLBACK</literal> will be sent to the database. The <literal>COMMIT</literal>
			or <literal>ROLLBACK</literal> will only be sent if <link linkend="profile-autocommit">autocommit</link> is turned off.
		</para>
		<para>
			Columns containing BLOB data will be displayed with a <guibutton>...</guibutton> button.
			By clicking on that button, you can view the blob data, save it to a file or upload 
			the content of a file to the DBMS. Please refer to <xref linkend="blob-support"/> 
			for details.
		</para>
			
		<para>
			Once you issue a new <literal>SELECT</literal> statement the edit mode will be
			turned off again. If you try to enable the edit mode for a result set where more
			than one table is involved, you will be prompted for the table that should
			be updated.
		</para>
      
		<para>
			When editing, &wb-productname; highlights columns that are defined as <literal>NOT NULL</literal>
			in the database. You can turn this feature off, or change the color that is used in the 
			<link linkend="options-required-field-color">options dialog</link>.
		</para>
			
		<para>
			When editing date, timestamp or time fields, the format specified 
			in the <link linkend="options-date-format">options dialog</link> is used 
			for parsing the entered value and converting that into the internal representation 
			of a date. The value entered must match the format defined there.
		</para>
	</section>
    
	<section id="using-copy-clipboard">
		<title>Copying result data to the clipboard</title>
		<para>
			Once you have retrieved data and it is displayed in the result set table,
			you can copy the data to the clipboard in various formats. These are the same
			formats available when exporting data using the <link linkend="command-export">WbExport</link>
			command.
		</para>
		<para>
			You can either copy all the data, or only selected rows to the clipboard. 
			When you select the menu item while holding down the <keycap>Control</keycap> key
			you will be able to select the columns that should be part of the data to be copied.
		</para>
	</section>
    
	<section id="filter-data">
		<title>Filtering the result</title>
		<para>Once the data has been retrieved from the Server it can be filtered
		with the need to re-retrieve the data.</para>
		<para>
			To define a filter, click on the (<literal>Filter</literal> <guiicon><inlinegraphic fileref="@IMAGE_DIR@/filter16.gif" format="GIF"/></guiicon>)
			button in the toolbar or select <menuchoice><guimenu>Data</guimenu><guimenuitem>Filter data</guimenuitem></menuchoice>.
			A dialog will appear where you can define a filter for the current result set. Each line
			in the filter dialog defines an expression that will be applied to the column selected
			in the first dropdown. If you select <literal>*</literal> for the column, the filter
			condition will be applied to all columns of the result set.
		</para>
		<para>
			To add a multi-column expression, press the <literal>More</literal> button, to create
			a new line. To remove a column expression from the filter, click the <literal>Remove</literal> 
			(<guiicon><inlinegraphic fileref="@IMAGE_DIR@/Remove16.gif" format="GIF"/></guiicon>) button.
			For character based column data, you can select to ignore the case of the column's data
			when applying the expression, i.e. when <literal>Ignore case</literal> is selected, the
			expression <literal>'NAME = arthur'</literal> will match the column value '<literal>Arthur</literal>', 
			and '<literal>ARTHUR</literal>'.
		</para>
		<para>
			By default, the column expressions are combined with an <literal>OR</literal>, i.e. 
			that a row will be displayed if at least one of the column expressions evaluates 
			to true. If you want to view only rows where <emphasis role="bold">all</emphasis>
			column expressions must match, select the <literal>AND</literal> radio button
			at the top of the dialog.
		</para>
	</section>
    
</section>
