<section id="wb-commands">
  <title>Special &wb-productname; commands</title>

  <section id="command-list">
    <title>LIST</title>
    
    <para>This command lists all available tables (including views and
      synonyms). This output is equivalent to the left part of the Database
      Object Explorer&#39;s Table tab.
    </para>
  </section>

  <section id="command-listprocs">
    <title>LISTPROCS</title>
    
    <para>This command will list all stored procedures available to the
    current user. The output of this command is equivalent to the Database
    Explorer&apos;s Procedure tab.</para>
  </section>

  <section id="command-desc">
    <title>DESCRIBE (DESC)</title>
    
    <para>Describe shows the definition of the given table. It can be
    abbreviated with DESC. The command expects the table name as a parameter.</para>
    <programlisting>DESC person;</programlisting>
    <para>If you want to show the structure of a table from a different user, you need
    to prefix the table name with the desired user</para>
    <programlisting>DESCRIBE otheruser.person;</programlisting>
  </section>

  <section id="command-listcat">
    <title>LISTCAT (LISTDB)</title>
    
    <para>Lists the available catalogs or databases. The output of this
    command depends on the underlying JDBC driver and DBMS. For MS SQL
    Server this lists the available databases (which then could be changed
    by USE &#60;dbname&#62;)</para>
    
    <para>For Oracle this command returns nothing (as Oracle does not
    implement the concept of catalogs)</para>
    <para>This command calls the JDBC driver&apos;s getCatalogs() method and will
    return its result. If on your database system this command does not display
    a list, it is most likely that your DBMS does not support catalogs (e.g. Oracle)
    or the driver does not implement this feature.
    </para>
  </section>

  <section id="command-export">
    <title>WBEXPORT</title>

    <para>Exports the result of the <emphasis role="bold">next</emphasis>
        SQL statement (which has to produce a result set) to a file without
        loading the data into memory. If you want to save the data that is 
        currently displayed in the result area into an external file, please 
        use the <link linkend="export">Save Data as</link> feature.
    </para>
    <para>If you want to simply export the contents of one or more tables, 
      the <literal>-sourcetable</literal> switch can be used to specify the 
      tables. In this case no additional SELECT statement is necessary. 
      You can also use the <link linkend="dbexplorer-spool">Database Explorer</link>
      to export multiple tables.
    </para>
    
    <para>The command supports the following parameters:</para>

    <informaltable frame="all">
      <tgroup cols="2" align="left">
        <colspec colname="c1" colwidth="4cm" />
        <colspec colname="c2" />
          <thead>
            <row>
              <entry>Parameter</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
              <row>
              <entry><para>-type=[text |sqlinsert |sqlupdate |sqldeleteinsert |xml |html]</para></entry>
              
              <entry>
                <para>
                  Defines the type of the output file. <literal>sqlinsert</literal>
                  will create the necessary <literal>INSERT</literal> statements to put
                  the data into a table. If the records may already exist in the target table
                  but you don't want to (or cannot) delete the content of the table
                  before running the generated script, &wb-productname; can create a DELETE
                  statement for every <literal>INSERT</literal> statement. To create this
                  kind of script, use the <literal>sqldeleteinsert</literal> type.
                </para>
                <para>
                  In order for this to work properly the table needs to have keycolumns defined,
                  or you have to define the keycolumns manually using the <literal>-keycolumns</literal>
                  switch.
                </para>
                <para>
                  <literal>sqlupdate</literal> will generate UPDATE 
                  statements that update all non-key columns of the table. This will only
                  generate valid <literal>UPDATE</literal> statements if at least one key
                  column is present. If the table does not have key columns defined, or you 
                  want to use different columns, they can be specified using the <literal>-keycolumns</literal>
                  switch.
                </para>
              </entry>
          </row>

          <row>
              <entry><para>-file=&#60;filename&#62;</para></entry>
              <entry><para>Defines the name of the output file </para></entry>
          </row>
          
          <row>
              <entry><para>-sourcetable=table1,table2</para></entry>
              <entry><para>Defines the table(s) to be exported. If this
              switch is used, <literal>-outputdir</literal> is also required
              unless exactly one table is specified. If one table is 
              specified, the -file parameter is used to generate the file
              for the table. If more then one table is specified, the 
              <literal>-outputdir</literal> parameter is used to defined
              the directory where the generated files should be stored. 
              Each file will be named as the exported table with the approriate
              extension (.xml, .sql, etc). You can specify * as the table
              name which will then export all tables accessible by the 
              current user.
              </para></entry>
          </row>
          <row>
              <entry><para>-outputdir=directory</para></entry>
              <entry><para>When using the <literal>-sourcetable</literal> switch
              with multiple tables, this parameter is mandatory and defines
              the directory where the generated files should be stored.
              </para></entry>
          </row>
          <row>
              <entry><para>-encoding</para></entry>
              <entry><para>Defines the encoding in which the file should be 
              written. Common encodings are ISO-8859-1, ISO-8859-15, UTF-8 (or UTF8).
              To get a list of available encodings, execut <literal>WBEXPORT</literal>
              with the parameter <literal>-showencoding</literal>
              </para></entry>
          </row>
          <row>
              <entry><para>-showencodings</para></entry>
              <entry><para>Displays the encodings supported by your Java version and 
              operating system. If this parameter is present, all other parameters are ignored.
              </para></entry>
          </row>
          <row>
            <entry><para>-lineending</para></entry>
            <entry><para>Defines the line ending used for XML or text files. Possible 
            values are: <literal>dos</literal>, <literal>win</literal>, <literal>crlf</literal>
            to create files that use the file ending using a CR (ASCII value 13) followed by 
            a LF (ASCII value 10). For a single character line ending using the LF character
            use the value <literal>lf</literal> or <literal>unix</literal>.
            The default line ending used depends on the platform where &wb-productname; is running.
            </para>
            </entry>
          </row>
          
        </tbody>
      </tgroup>
    </informaltable>

    <section id="spool-sql-parameters">
      <title>Additional parameters for type SQLUPDATE, SQLINSERT or SQLDELETEINSERT</title>

      <informaltable frame="all">
        <tgroup cols="2" align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
          <thead>
            <row>
              <entry>Parameter</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para>-table</para></entry>

              <entry><para>Define the tablename to be used for the UPDATE or INSERT 
              statements. This parameter is required if the SELECT statement has 
              multiple tables in the FROM list. It can be used if only the data
              is retrieved from only one table to UPDATE or INSERT into a different
              table.</para></entry>
            </row>

            <row>
              <entry><para id="export-sql-cleanup">-charfunc</para></entry>

              <entry><para>If this parameter is given, any
              non-printable character in a text/character column will be
              replaced with a call to the given function with the ASCII
              value as the parameter. </para> <para>If -charfunc=chr is
              given (e.g. for an Oracle syntax), a CR (=13) inside a
              character column will be replaced with:</para>
              <para><literal>INSERT
              INTO ... VALUES (&#39;First line&#39;||chr(13)||&#39;Second
              line&#39; ... )</literal></para>

              <para>This setting will affect ASCII values from 0 to 31</para>
              </entry>
            </row>

            <row>
              <entry><para>-concat</para></entry>

              <entry><para>If the parameter <literal>-charfunc</literal> is used
              &wb-productname; will concatenate the individual pieces using 
              the ANSI SQL operator for string concatenation. In case 
              your DBMS does not support the ANSI standard (e.g. MS ACCESS) 
              you can specify the operator to be used:</para>
              <para><literal>-concat=+</literal></para><para> defines the plus sign
              as the concatenation operator.</para></entry>
            </row>

            <row>
              <entry><para>-commitevery</para></entry>

              <entry><para>A numeric value which identifies
              the number of <literal>INSERT</literal> or <literal>UPDATE</literal> statements 
              after which a <literal>COMMIT</literal> is put into the generated SQL script.</para>
              <para>-commitevery=100</para>
              <para>will create a <literal>COMMIT;</literal> after every 100th statement.</para>
              </entry>
            </row>

            <row>
              <entry><para>-createtable=[true|false]</para></entry>

              <entry><para>If this parameter is set to true,
              the necessary <literal>CREATE TABLE</literal> command is put into the output
              file. This parameter is ignored when creating <literal>UPDATE</literal>
              statements.</para>
              </entry>
            </row>
            
            <row>
              <entry><para>-keycolumns=column1, column2, ...</para></entry>

              <entry><para>
              If the table does not have key columns, or the source SELECT statement uses
              a join over several tables, or you do not want to use the key columns defined 
              in the database, this key can be used to define the key columns to be used
              for the UPDATE statements. This key overrides any key columns defined on the
              base table of the SELECT statement.
              </para></entry>
            </row>
            
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="spool-text-parameters">
      <title>Parameters for the type TEXT</title>

      <informaltable frame="all">
        <tgroup cols="2"  align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
          <thead>
            <row>
              <entry>Parameter</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para>-delimiter</para></entry>

              <entry><para>The given string sequence will be
              placed between two columns. The default is a tab character
                              (<literal>-delimiter=\t</literal>
                              </para></entry>
            </row>

            <row>
              <entry><para>-dateformat</para></entry>

              <entry><para>The date format to be used when
              writing date columns into the output file. The syntax of the
              format definition, is the same as for the SimpleDateFormat
              class.</para></entry>
            </row>

            <row>
              <entry><para>-datetimeformat</para></entry>

              <entry><para>The format to be used when writing
              datetime (or timestamp) columns into the output file.
              </para></entry>
            </row>

            <row>
              <entry><para>-quotechar</para></entry>

              <entry><para>The character (or sequence of characters) to be used 
                  to enclose text (character) data if the delimiter is 
                  contained in the data. By default quoting is disabled until a quote character
                  is defined. To set the double quote as the quote character
                  you have to enclose it in single quotes: <literal>-quotechar='"'</literal>
              </para></entry>
            </row>
            
            <row>
              <entry><para>-quoteAlways</para></entry>

              <entry><para>If quoting is enabled (via <literal>-quotechar</literal>,
                  then character data will only be quoted
                  if the delimiter is found inside the actual value that is
                  written to the output file. If <literal>-quoteAlways=true</literal> is
                  specified, character data will always be 
                  enclosed in the specified quote character.</para>
              </entry>
            </row>
            
            <row>
              <entry><para>-decimal</para></entry>

              <entry><para>The decimal symbol to be used for
                  numbers. The default is a dot (e.g. 3.14152)</para>
              </entry>
            </row>

            <row>
              <entry><para>-cleancr=[true|false]</para></entry>

              <entry><para>Controls the handling of non
                  printable characters inside character columns. If
                  <literal>-cleancr=true</literal>, any character &#60; ASCII 32 will 
                  be replaced with a space character. This results in 
                  exported data that is different to the content of the database, 
                  but will allow importing using tools that do not 
                  support embedded newlines. 
                  If you plan to use <literal>WBIMPORT</literal> to import
                  the textfile, then using the <literal>-escapetext</literal> flag
                  is the recommended way to deal with special characters. Using 
                  the text encoding offered by <literal>WBIMPORT/WBEXPORT</literal>
                  special characters can be written and restored using text files that would
                  otherwise not support this.
              </para></entry>
            </row>
            
            <row>
              <entry><para id="text-escape-switch">-escapetext</para></entry>

              <entry><para>This parameter controls the escaping of non-printable 
              or non-ASCII characters. Valid options are <literal>ctrl</literal> which
              will escape everything below ASCII 32 (newline, tab, etc), <literal>7bit</literal>
              which will escape everything below ASCII 32 and above 126, <literal>8bit</literal>
              which will escape everything below ASCII 32 and above 255 and <literal>extended</literal>
              which will escape everything outside the range [32-126] and [161-255]
              </para>
              <para>This will write a unicode representation of the character into the 
              text file e.g. \n for a newline, \u00F6 for &ouml;. This file 
              can only be imported using &wb-productname; (at least I don't know
              of any DBMS specific loader that will decode this properly)</para>
              </entry>
            </row>

            <row>
              <entry><para>-header=[true|false]</para></entry>

              <entry><para>If this parameter is set to true,
              the header (i.e. the column names) are placed into the
              output file. The default is to not create a header line.
                              </para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="spool-xml-parameters">
      <title>Parameters for type XML</title>

      <informaltable frame="all">
        <tgroup cols="2" align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
          <thead>
            <row>
              <entry>Parameter</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody valign="top">
            <row>
              <entry><para>-table</para></entry>
              <entry><para>The given tablename will be put
              into the &#60;table&#62; tag as an attribute.</para></entry>
            </row>

            <row>
              <entry><para>-dateformat</para></entry>
              <entry><para>The date format to be used when
              writing date columns into the output file. The syntax of the
              format definition, is the same as for the SimpleDateFormat
              class.</para></entry>
            </row>

            <row>
              <entry><para>-datetimeformat</para></entry>
              <entry><para>The format to be used when writing
              datetime (or timestamp) columns into the output file.
              </para></entry>
            </row>

            <row>
              <entry><para>-decimal</para></entry>
              <entry><para>The decimal symbol to be used for
              numbers. The default is a dot (e.g. 3.14152)</para></entry>
            </row>
            <row>
              <entry><para>-usecdata</para></entry>
              <entry><para>Normally any character data written into the xml file will
                  be processes to escape XML characters (e.g. &lt; will be written as &amp;lt;).
                  If you don't want that escaping, set <literal>-usecdata=true</literal> and
                  all character data (VARCHAR, etc) will be enclosed in a CDATA section.</para>
                  <para>With <literal>-cdata=true</literal> a HTML value would be written like this:</para>
                  <para>
                  <literal>&lt;![CDATA[&lt;b&gt;This is a title&lt;/b&gt;]]&gt;</literal>
                  </para>
                  <para>
                  With <literal>-cdata=false</literal> (the default) a HTML value would be written like this:</para>
                  <para>
                  <literal>&amp;lt;b&amp;gt;This is a title&amp;lt;/b&amp;gt;</literal>
                  </para>
              </entry>
            </row>

            <row>
              <entry><para>-stylesheet</para></entry>
              <entry><para>The name of the XSLT stylesheet that should be used
              to transform the &wb-productname; specific XML file into a 
              different format. If -stylesheet is specified, -xsltoutput has
              to be specified as well.</para></entry>
            </row>
            <row>
              <entry><para>-xsltoutput</para></entry>
              <entry><para>The resulting output file (specified 
              with the -file parameter), can be transformed using XSLT after
              the export has finished. This parameter then defines 
              the name of the outputfile of the transformation.</para></entry>
            </row>
            <row>
              <entry><para>-verboseXML=[true|false]</para></entry>
              <entry><para>This parameter controls the tags that 
              are used in the XML file and minor formatting features.
              The default is -verboseXML=true and this will generate 
              more readable tags and formatting. However the overhead
              imposed by this is quite high. Using -verboseXML=false
              uses shorter tag names (not longer then two characters) and
              does put more information in one line. This output is 
              a harder to read for a human but is smaller in size which 
              could be important for exports with large result sets.
              </para></entry>
            </row>
            
          </tbody>
        </tgroup>
      </informaltable>

    </section>
    <section id="export-examples">
      <title>Examples:</title>

      <programlisting>WBEXPORT -type=text -file='c:/data/data.txt' -delimiter='|' -decimal=',';
SELECT * FROM data_table;</programlisting>

    <para>Will create a text file with the data from <literal>data_table</literal>.
        Each column will be separated with the character | Each fractional number
        will be written with a comma as the decimal separator. As the
        SELECT statement retrieves all rows and columns from the table, this
        could also be written as: 
    </para>

    <programlisting>WBEXPORT -type=text -file='c:/data/data.txt' -delimiter='|' -decimal=',' -sourcetable=data_table;</programlisting>
    <para>There is a difference in the behaviour of the command regarding the "Max. Rows" setting
    in the GUI. When you use the <literal>WBEXPORT</literal> command together with 
    a <literal>SELECT</literal> query, the Max. Rows setting will be respected
    by the <literal>SELECT</literal> statement (and you will see a warning
    that the result set was limited). When you use the <literal>WBEXPORT</literal>
    with the <literal>-sourcetable</literal> switch, the "Max. Rows" setting 
    will not be respected, and all rows from the table will be written into
    the specified file.</para>
    
    <para>To generate a file that contains SQL INSERT statements that can be
      executed on the target system, the following command can be used:</para>

    <programlisting>WBEXPORT -type=sqlinsert -file='c:/data/newtable.sql' -table=newtable;
SELECT * FROM table1, table2
WHERE table1.column1 = table2.column1;</programlisting>

      <para>Will create a SQL scripts which inserts the data from table1
      and table2 into a table called newtable. If the parameter -table is
      omitted, the creation of SQL INSERT statements is only possible, if the SELECT is
      based on a single table (or view).</para>
      <para>For more details on how you can export and import data using the XML format
      please refer to <xref linkend="xml-export-import"/></para>
    </section>
    <section id="export-date-formats">
      <title>Specifying date formats</title>
      <para>The date/time format that can be specified with the <literal>-dateformat</literal>
      or <literal>-timestampformat</literal> accepts fhe following format codes. These
      are the format codes for Java's <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</ulink>
      class.
      </para>
      <para>
        <simplelist type='horiz' columns='2'>
        </simplelist>
      </para>
    </section>

</section>

  <section id="command-import">
    <title>WBIMPORT</title>
    <para>The WBIMPORT command can be used to import data from text or
          XML files into a table in the database. WBIMPORT can read the XML files generated by the
    <link linkend="command-export">WBEXPORT</link> command&apos;s XML format. It can
    also read text files created by the WBEXPORT command that escape non-printable
    characters.
    </para>
    <para>During the import of text files, empty lines (i.e. lines which only
          contain whitespace) will be silently ignored. The text import does not support records
          spanning multiple lines in the input file. If the input file is created using
          WBEXPORT then it is recommended to use the <literal>-escape</literal> switch
          to escape non-printable characters which could break text import.</para>

    <para>The WBIMPORT command has the following syntax</para>
    <informaltable frame="all">
      <tgroup cols="2" align="left">
        <colspec colname="c1" colwidth="4cm" />
        <colspec colname="c2"/>
        <thead>
          <row>
            <entry>Parameter</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody valign="top">
          <row>
            <entry><para>-type=[xml|text]</para></entry>
            <entry><para>Defines the type of the input file</para></entry>
          </row>
          <row>
            <entry><para>-file</para></entry>
            <entry><para>Defines the full name of the input file. For XML imports
            you can also specify a directory (using <literal>-sourcedir</literal>
            from which all xml files are imported</para></entry>
          </row>
          <row>
            <entry><para>-commitevery</para></entry>
            <entry><para>Issue a commit every (number) rows. If this parameter
            is not passed (or a value of zero or lower), then &wb-productname; will commit
            everything when all rows have been imported. </para></entry>
          </row>
          <row>
            <entry><para>-mode</para></entry>
            <entry><para>Defines how the data should be sent to the database. Possible
            values are <literal>INSERT</literal>, <literal>UPDATE</literal>,
            <literal>INSERT,UPDATE</literal> and <literal>UPDATE,INSERT</literal>
            For details please refer to the <link linkend="import-update-mode">update mode</link>
            explanation.
            </para>
            </entry>
          </row>
          <row>
            <entry><para>-ContinueOnError</para></entry>
            <entry><para>This parameter controls the behaviour when errors occur during
            the import. The default is <literal>true</literal>, meaning that the import
            will continue even if an error occurs during file parsing or updating the database. 
            Set this parameter to <literal>false</literal>
            if you want to stop the import as soon as an error occurs.
            </para></entry>
          </row>
          <row>
            <entry><para>-keyColumns</para></entry>
            <entry><para>Defines the key columns for the target table. This parameter
            is only necessary if import is running in <literal>UPDATE</literal> mode.
            </para>
            <para>
            This parameter is ignored if XML files are imported using the <literal>-sourcedir</literal>
            parameter
            </para></entry>
          </row>
          <row>
            <entry><para>-table</para></entry>
            <entry><para>Defines the table into which the data should be imported</para>
            <para>This parameter is ignored if XML files are imported using the <literal>-sourcedir</literal>
            parameter
            </para></entry>
          </row>
          <row>
            <entry><para>-schema</para></entry>
            <entry><para>Defines the schema into which the data should be imported. This 
            is necessary for DBMS that support schemas, and you want to import
            the data into a different schema, then the current one.</para>
            </entry>
          </row>
          <row>
            <entry><para>-encoding</para></entry>
            <entry><para>Define the encoding for the input file. For XML files
            the default encoding is UTF-8, for text files it's ISO-8859-1</para></entry>
          </row>
          <row>
            <entry><para>-deletetarget</para></entry>
            <entry><para>If this parameter is set to true, data from the target table will
            be deleted (using <literal>DELETE FROM ...</literal>) before the import is started.
            </para></entry>
          </row>
          <row>
            <entry><para>-usebatch</para></entry>
            <entry><para>Enable or disable the use of the JDBC batch update features. If the
            JDBC driver supports this, the INSERT (or UPDATE) performance can be increased. 
            This parameter will be ignored if the driver does not support batch updates or if 
            the mode is not UPDATE or INSERT (i.e. if <literal>-mode=update,insert</literal>
              or <literal>-mode=insert,update</literal>is used).
              Note that for some JDBC drivers this means that all SQL statements that 
              are generated for the input file will be kept in memory until the batch 
              is execute, so for large input files this might lead to memory problems.
              In this case the size of the batch queue should be controlled using
              the <literal>-batchsize</literal> parameter.
            </para></entry>
          </row>
          <row>
              <entry><para>-batchsize</para></entry>
              <entry><para>
                  Controls the size of the batch if <literal>-usebatch=true</literal>
                  is used. If this parameter is not specified then <emphasis role="bold">all</emphasis>
                  generated SQL statements will be put into the batch queue</para>
              </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section id="import-text-parameters">
      <title>Parameters for the type TEXT</title>

      <informaltable frame="all">
        <tgroup cols="2"  align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
          <thead>
            <row>
              <entry>Parameter</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para>-filecolumns</para></entry>
              <entry><para>A comma separated list of the table columns in the import file
              Each column from the file should be listed with the approriate column
              name from the target table. This parameter also defines
              the order in which those columns appear in the file.
              If the file does not contain a header line or the header line does not 
              contain the names of the columns in the database (or has different names), 
              this parameter has to be supplied. If a column from the input 
              file has no match in the target table, then it should be specified with 
              the name $wb_skip$. You can also specify the $wb_skip$ flag for
              columns which are present but that you want to exclude from the 
              import.
              </para></entry>
            </row>
            <row>
              <entry><para>-importcolumns</para></entry>
              <entry><para>Defines the columns that should be imported. If all 
              columns from the input file should be imported (the default), then 
              this parameter can be ommited. If only certain columns should be 
              imported then the list of columns can be specified here. The column
              names should match the names provided with the -filecolumns switch.
              The same result can be achieved by providing the columns
              that should be excluded as <literal>$wb_skip$</literal> columns
              in the <literal>-filecolumns</literal> switch. Which one you choose
              is mainly a matter of taste. Listing all columns and excluding
              some using <literal>-importcolumns</literal> might be more readable
              because the structure of the file is still "visible" in the 
              <literal>-filecolumns</literal> switch.
              </para></entry>
            </row>
            <row>
              <entry><para>-delimiter</para></entry>
              <entry><para>Define the character which separates columns in one line. Records are always
              separated by newlines (either CR/LF or only a LF character)</para></entry>
            </row>

            <row>
              <entry><para>-dateformat</para></entry>
              <entry><para>The format for date columns
              The syntax of the format definition, is the same as for the SimpleDateFormat
              class.</para></entry>
            </row>

            <row>
              <entry><para>-datetimeformat</para></entry>
              <entry><para>The format for datetime (or timestamp) columns in the input file.
              </para></entry>
            </row>

            <row>
              <entry><para>-quotechar</para></entry>
              <entry><para>The character which was used to quote values where the delimiter is contained.
              </para></entry>
            </row>

            <row>
              <entry><para>-decimal</para></entry>
              <entry><para>The decimal symbol to be used for
              numbers. The default is a dot.</para></entry>
            </row>

            <row>
              <entry><para>-header=[true|false]</para></entry>
              <entry><para>If set to true, indicates that the file contains a header
              line with the column names for the target table. This will also ignore
              the data from the first line of the file. If the column names
              to be imported are defined using the <literal>-columns</literal> switch,
              this parameter has to be set to true nevertheless, otherwise the first column
              would be treated as a regular data column.
              </para></entry>
            </row>
            <row>
              <entry><para>-decode=[true|false]</para></entry>
              <entry><para>This controls the decoding of escaped characters. If the 
              export file was e.g. written with <link linkend="text-escape-switch">escaping enabled</link> 
              then you need to set <literal>-decode=true</literal> in order to interpret string sequences
              like \t, \n or escaped Unicode characters properly.
              </para></entry>
            </row>
            <row>
              <entry><para>-columnfilter</para></entry>
              <entry><para>
                This defines a filter on column level that selects only certain rows
                from the input file to be sent to the database. The filter has to be 
                define <literal>as column1="regex",column2="regex"</literal>
              </para>
              <para>If more then one column is listed, then all expressions must match
              in order for the input row to be processed. The expressions to be applied to
              the input value are regular expressions.
              </para>
              </entry>
            </row>
            <row>
              <entry><para>-linefilter</para></entry>
              <entry><para>
              To define a filter on the level of the input row (rather then
              for each column individually) you can define a regular expression
              that is applied to the whole input row. As the regular expressioin 
              will be applied to the input row as it is retrieved from the 
              input file, the column delimiter(s) have to be taken into account 
              when defining the regular expression.
              </para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      
      <para>Examples:</para>
      <programlisting>WBIMPORT -file=c:/temp/contacts.txt
         -table=person
         -filecolumns=lastname,firstname,birthday
         -dateformat="yyyy-MM-dd";</programlisting>
     
     <para>
         This imports a file with three columns into a table named person. The 
         first column in the file is <literal>lastname</literal>, the second column
         is <literal>firstname</literal> and the third column is <literal>birhtday</literal>.
         Values in date columns are formated as yyyy-MM-dd
     </para>
     
      <programlisting>WBIMPORT -file=c:/temp/contacts.txt
         -table=person
         -filecolumns=lastname,firstname,$wb_skip$,birthday
         -dateformat="yyyy-MM-dd";</programlisting>
     
     <para>
         This will import a file with four columns. The third column in the file
         does not have a corresponding column in the table <literal>person</literal>
         so its specified as <literal>$wb_skip$</literal> and will not be imported. 
     </para>
     
      <programlisting>WBIMPORT -file=c:/temp/contacts.txt
         -table=person
         -filecolumns=lastname,firstname,phone,birthday
         -importcolumns=lastname,firstname;</programlisting>
     
      <para>
          This will import a file with four columns where all columns
          exist in the target table. Only <literal>lastname</literal> and 
          <literal>firstname</literal> will be imported. The same effect could 
          be achieved by specifying $wb_skip$ for the last two columns and leaving
          out the -importcolumns switch. Using -importcolumns is a bit more readable
          because you can still see the structure of the input file. The 
          version with <literal>$wb_skip$</literal> is mandatory if the input file
          contains columns that do not exist in the target table.
      </para>
     
     <para>If you want to import certain rows from the input file, you can 
     use regular expressions:</para>
      <programlisting>WBIMPORT -file=c:/temp/contacts.txt
         -table=person
         -filecolumns=lastname,firstname,birthday
         -columnfilter=lastname="^Bee.*",firstname="^Za.*"
         -dateformat="yyyy-MM-dd";</programlisting>
     <para>The above statement will import only rows where the column <literal>lastname</literal>
     contains values that start with <literal>Bee</literal> and the column <literal>firstname</literal>
     contains values that start with <literal>Za</literal>. So <literal>Zaphod Beeblebrox</literal>
     would be imported, <literal>Arthur Beeblebrox</literal> would not be imported.
     </para><para>
     If you want to learn more about regular expressions, please have a look
     at <ulink url="http://www.regular-expressions.info/"/>
     </para>
    </section>

    <section id="import-xml-parameters">
      <title>Parameters for the type XML</title>
      <para>The XML import only works with files generated by the <link linkend="command-export">WBEXPORT</link>
      command.</para>
        <informaltable frame="all">
          <tgroup cols="2"  align="left">
            <colspec colname="c1" colwidth="4cm" />
            <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry><para>-verboseXML=[true|false]</para></entry>
                <entry><para>If the XML was generated with <literal>-verboseXML=false</literal>
                then this needs to be specified also when importing the file.
                Beginning with build 78, the &wb-productname; writes the information
                about the used tags into the meta information. So it is no 
                longer necessary to specify whether -verboseXML was true when 
                creating the XML file.
                </para></entry>
              </row>
              <row>
                <entry><para>-sourcedir</para></entry>
                <entry><para>Specify a director which contains the XML files. 
                All files in that directory where the name ends with ".xml" 
                (lowercase!) will be processed. 
                The table into which the data is imported is read
                from the XML file, also the columns to be imported. The parameters
                <literal>-keycolumns</literal>, <literal>-table</literal> and 
                <literal>-file</literal> are ignored if this parameter is specified.
                If XML files are used that are generated with a version prior to 
                build 78, then all files need to use either the long or short
                tag format and the <literal>-verboseXML=false</literal> parameter has
                to be specified if the short format was used.
                </para>
                <para>When importing several files at once, the files will be 
                imported into the tables specified in the XML files. You cannot 
                specify a different table (apart from editing the XML file 
                before starting the import).
                </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
    </section>
    
    <section id="import-update-mode">
      <title>Update mode</title>
      <para>The <literal>-mode</literal> parameter controls the way the data is send
        to the database. The default is <literal>INSERT</literal>. &wb-productname; will
        generate an <literal>INSERT</literal> statement for each record. If the <literal>INSERT</literal>
        fails no further processing takes place for that record.
      </para>
      <para>If <literal>-mode</literal> is set to <literal>UPDATE</literal>, &wb-productname; will
        generate an <literal>UPDATE</literal> statement for each row. In order for this to work,
        the table needs to have a primary key defined, and all columns of the primary key need to
        be present in the import file. Otherwise the generated <literal>UPDATE</literal> statement
        will modify rows that should not be modified. This can be used to update existing
        data in the database based on the data from the export file.
      </para>
      <para>To either update or insert data into the table, both keywords can be specified
        for the <literal>-mode</literal> parameter. The order in which they appear as the parameter
        value, defines the order in which the respective statements are sent to the database. If the first
        statement fails, the second will be executed. For <literal>-mode=insert,update</literal> to
        work properly a primary or unique key has to be defined on the table. &wb-productname;
        will catch any exception (=error) when inserting a record, then it will try updating
        the record, based on the specified keycolumns.
        The <literal>-mode=update,insert</literal> works the other way. First &wb-productname;
        will try to update the record based on the primary keys. If the DBMS signals that no rows
        have been updated, it is assumed that the row does not exist and the record will be inserted
        into the table. This mode is recommended when no primary or unique key is defined on the table,
        and an <literal>INSERT</literal> would always succeed.
      </para>
      <para>The keycolumns defined with the <literal>-keycolumns</literal> parameter don't
      have to match the real primary key, but they should identify one row uniquely.
      </para>
     <para>You cannot use the update mode, if you select <emphasis role="bold">only</emphasis> key columns.
     The values from the source are used to build up the <literal>WHERE</literal> clause for the 
     <literal>UPDATE</literal> statement. If ony key columns are defined, then there would be nothing to 
     update.
      </para>

      <para>
        For maximum performance, choose the update strategy that will result in a succssful
        first statement more often. As a rule of thumb:
        <itemizedlist>
          <listitem><para>Use <literal>-mode=insert,update</literal>, if you expect more rows to be inserted then updated.</para></listitem>
          <listitem><para>Use <literal>-mode=update,insert</literal>, if you expect more rows to be updated then inserted.</para></listitem>
        </itemizedlist>
      </para>
    </section>

  </section>
    
  <section id="command-xslt">
    <title>XSLT</title>

    <para>Transform an XML file via a XSLT stylesheet. This can be used to format 
    XML input files into the correct format for &wb-productname; or to transform
    the output files that are generated.</para>
    <para>Parameters for the XSLT command:</para>
      <informaltable frame="all">
        <tgroup cols="2"  align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
          <thead>
            <row>
              <entry>Parameter</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para>-inputfile</para></entry>
              <entry><para>The name of the XML source file.</para></entry>
            </row>
            <row>
              <entry><para>-xsltoutput</para></entry>
              <entry><para>The name of the generated output file.</para></entry>
            </row>
            <row>
              <entry><para>-stylesheet</para></entry>
              <entry><para>The name of the XSLT stylesheet to be used.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
  </section>

    <section id="command-copy">
      <title>WBCOPY</title>
      <para>The <literal>WBCOPY</literal> is essentially the command line version of the
      the <link linkend="data-pumper">DataPumper</link>. For a more detailed explanation
      of the copy process, please refer to that section. It bascially chains a WBEXPORT and a
            WBIMPORT statement without the need of an intermediate data file. The WBCOPY command
            requires that a connection to the source and target database can be made at the same time.
      </para>

      <section id="copy-general-parameters">

        <title>General parameters for the <literal>WBCOPY</literal> command.</title>
        <informaltable frame="all">
          <tgroup cols="2"  align="left">
            <colspec colname="c1" colwidth="4cm" />
            <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>

            <tbody valign="top">
              <row>
                <entry><para>-sourceprofile</para></entry>
                <entry><para>The name of the connection profile to use as the source connection.
                If -sourceprofile is not specified, the current connection is used as the source.
                </para></entry>
              </row>
              <row>
                <entry><para>-targetprofile</para></entry>
                <entry><para>The name of the connection profile to use as the target connection. If either
                -targetprofile is not specified, the current connection is used as the target.</para></entry>
              </row>
              <row>
                <entry><para>-commitevery</para></entry>
                <entry><para>The number of rows after which a commit is send to the target database.</para></entry>
              </row>
              <row>
                <entry><para>-deletetarget=[true|false]</para></entry>
                <entry><para>If this parameter is set to true, all rows are deleted from the
                target table before copying the data.</para></entry>
              </row>
              <row>
                <entry><para>-mode</para></entry>
                <entry><para>Defines how the data should be sent to the database. Possible
                values are <literal>INSERT</literal>, <literal>UPDATE</literal>,
                <literal>INSERT,UPDATE</literal> and <literal>UPDATE,INSERT</literal>. Please
                refer to the description of the WBIMPORT command for details on the update mode.
                </para></entry>
              </row>
              <row>
                <entry><para>-keycolumns</para></entry>
                <entry><para>Defines the key columns for the target table. This parameter
                is only necessary if import is running in <literal>UPDATE</literal> mode.
                </para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="copy-single-table">
        <title>Copying data from a single table.</title>
        <informaltable frame="all">
          <tgroup cols="2"  align="left">
            <colspec colname="c1" colwidth="4cm" />
            <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry><para>-sourcetable=&lt;tablename&gt;</para></entry>
                <entry><para>The name of the table to be copied.</para></entry>
              </row>
              <row>
                <entry><para>-sourcewhere=&lt;condition&gt;</para></entry>
                <entry><para>A WHERE condition which is applied to the source table.</para></entry>
              </row>
              <row>
                <entry><para>-targettable=&lt;tablename&gt;</para></entry>
                <entry><para>The name of the table into which the data should be written.</para></entry>
              </row>
              <row>
                <entry><para>-createtarget=[true|false]</para></entry>
                <entry><para>If this parameter is set to <literal>true</literal> the target table
                will be created, if it doesn't exist.</para></entry>
              </row>
              <row>
                <entry><para>-droptarget=[true|false]</para></entry>
                <entry><para>If this parameter is set to <literal>true</literal> the target table
                will be dropped before it is create. This parameter is ignored if -createtarget
                is <literal>false</literal></para></entry>
              </row>
              <row>
                <entry><para>-columns=[&lt;list&gt;|&lt;mapping&gt;]</para></entry>
                <entry>
                  <para>Defines the columns to be copied. If this parameter is not specified, then
                  all matching columns are copied from source to target. Matching
                  is done on name <emphasis role="bold">and</emphasis> data type.
                  </para>
                  <para>&lt;list&gt; is a list of columns in the source table. The data from
                  each table will be copied into the corresponding column in the target table.
                  If <literal>-createtable=true</literal>, then
                  the list also defines the columns of the target table. The names have to be separated
                  by comma: <literal>-columns=firstname, lastname, zipcode</literal>
                  </para>
                  <para>
                  &lt;mapping&gt; defines a column mapping between the source and the target table
                  if the column names do no match. If <literal>-createtable=true</literal> then the
                  target table will be created from the specified target names:
                  <literal>-columns=firstname/surname, lastname/name, zipcode/zip</literal> Will copy the column
                  <literal>firstname</literal> from the source table to a column named <literal>surname</literal>
                  in the target table, and so on.
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="command-copy-query">
        <title>Copying data based on a SQL query</title>
        <informaltable frame="all">
          <tgroup cols="2"  align="left">
            <colspec colname="c1" colwidth="4cm" />
            <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><para>-sourcequery=&lt;SELECT statement&gt;</para></entry>
                <entry><para>The SQL query to be used as the source data (instead of a table).</para></entry>
              </row>
              <row>
                <entry><para>-columns=&lt;list&gt;</para></entry>
                <entry><para>The list of columns of the target table, in the order
                in which they appear in the source table.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="copy-update-mode">
        <title>Update mode</title>
        <para>The <literal>COPY</literal> command understands the same update mode
        parameter as the <literal>WBIMPORT</literal> command. For a discussion on
        the different update modes, please refer to the <link linkend="import-update-mode">WBIMPORT</link>
        command.</para>
      </section>
      
      <section id="copy-examples">
        <title>Examples:</title>
        <para>Copy all columns from one table to another table with the same columns:</para>
        <programlisting>WBCOPY -sourceprofile=ProfileA
       -targerprofile=ProfileB
       -sourcetable=the_table
       -targettable=the_other_table;</programlisting>

        <para>Copy all columns from one table to another table with the same columns, but
              only certain rows.</para>
        <programlisting>WBCOPY -sourceprofile=ProfileA
       -targerprofile=ProfileB
       -sourcetable=the_table
       -sourcewhere="lastname LIKE 'D%'
       -targettable=the_other_table;</programlisting>

        <para>Copy only selected columns to a table with different column names. Before the
        copy is started all rows are deleted from the target table:
        </para>
        <programlisting>WBCOPY -sourceprofile=ProfileA
       -targerprofile=ProfileB
       -sourcetable=person
       -targettable=contact
       -deletetarget=true
       -columns=firstname/surname, lastname/name, birthday/bday;</programlisting>
       <para>If you use this way to map columns, please make sure that you
        don't use the forward slash as the <link linkend="options-alternate-delimiter">alternate delimiter</link>.
                This can be achieved by either specifying a different character sequence or making sure
                that - if you use the forward slash - the current script does not end with it, as
                this turns on the usage of the alternate delimiter. The above example would work even if
                the forward slash was used as the alternate delimiter, because the whole command is
                terminated with a semicolon, which disables the usage of the alternate delimiter.
                </para>

        <para>Copy data based on a SQL query, matching the columns
        from the query to the corresponding columns from the target table:</para>
        <programlisting>WBCOPY -sourceprofile=ProfileA
       -targerprofile=ProfileB
       -sourcequery="SELECT firstname, lastname, birthday FROM person"
       -targettable=contact
       -deletetarget=true
       -columns=surname, name, bday;</programlisting>
       <para>The order in the <literal>-columns</literal> parameter <emphasis role="bold">must</emphasis>
       match the order in the <literal>SELECT</literal> statement!</para>
     </section>

    </section>

    <section id="command-schema-report">
      <title>WBREPORT</title>

      <para>Creates an XML report of selected tables. This report could be used
      to generate an HTML documentation of the database (e.g. using the <link linkend="command-xslt">XSLT</link>
      command). This report can also be generated from within the <link linkend="dbexplorer">Database Object Explorer</link>
      </para>
      <!-- <para>
        The resulting XML file could e.g. be transformed in a HTML documentation of your database schema.
                A sample stylesheet to do so can be downloaded from <ulink url="http://www.sql-workbench.net"/>.
      </para> 
      -->
      <para>Using this command you can reverse engineer an existing database. The XML file
      can then be used to generate a HTML documentation of the database or to be transformed
      into a format that is supported by your design tool.</para>
      
      <para>The command supports the following parameters:</para>

      <informaltable frame="all">
        <tgroup cols="2" align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>

          <tbody valign="top">
            <row>
              <entry><para>-file</para></entry>
              <entry><para>The filename of the output file.</para></entry>
            </row>
            <row>
                <entry><para>-tables</para></entry>
                <entry><para>A (comma separated) list of tables to report. Default is 
                all tables. If this parameter is specified <literal>-schemas</literal> is ignored.
                If you want to generate the report on tables from different users/schemas you have
                to use fully qualified names in the list (e.g. <literal>-tables=MY_USER.TABLE1,OTHER_USER.TABLE2</literal>)
                You can also specify wildcards in the table name: <literal>-table=CONTRACT_%</literal> will create
                an XML report for all tables that start with <literal>CONTRACT_</literal>
                </para></entry>
            </row>
            <row>
                <entry><para>-schemas</para></entry>
                <entry><para>A (comma separated) list of schemas to generate the report from. 
                For each user/schema all tables are included in the report. e.g. 
                <literal>-schemas=MY_USER,OTHER_USER</literal> would generate a report
                for all tables in the schemas <literal>MY_USER</literal> and <literal>OTHER_USER</literal>.
                </para></entry>
            </row>
            <row>
                <entry><para>-namespace</para></entry>
                <entry><para>The namespace to be used for the XML tags. By default no
                namespace is used. If you supply a value for this e.g. <literal>wb</literal> the tag <literal>&lt;schema-report&gt;
                </literal> would be written as <literal>&lt;wb:schema-report&gt;</literal>
                </para></entry>
            </row>
            <row>
                <entry><para>-format</para></entry>
                <entry><para>The format of the outputfile. The default is the &wb-productname;
                specific XML format. Using <literal>-format=dbdesigner</literal> you can generate
                an XML file suitable to be opened with DbDesigner4
                </para></entry>
            </row>
          </tbody>
        </tgroup>
     </informaltable>
   </section>
   <section id="command-diff">
    <title>WBDIFF</title>
    <para>The <literal>WBDIFF</literal> analyzes two schemas (or a list of tables) 
    and outputs the differences between those schemas as an XML file. The XML file
    describes the changes that need to be applied to the target schema to have 
    the same structure as the reference schema, e.g. modify column definitions, 
    remove or add tables, remove or add indexes. Currently it does not include 
    foreign key references.
    </para>
    <para>The output is intended to be transformed using XSLT (e.g. with the 
    <link linkend="command-xslt">XSLT Command</link>)
    </para>
      <para>The command supports the following parameters:</para>

      <informaltable frame="all">
        <tgroup cols="2" align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>

          <tbody valign="top">
            <row>
                <entry><para>-sourceprofile</para></entry>
                <entry><para>The name of the connection profile for the reference
                connection. If this is not specified, then the current connection is
                used.</para></entry>
            </row>
            <row>
                <entry><para>-targetprofile</para></entry>
                <entry><para>The name of the connection profile for the target
                connection (the one that needs to be migrated). If this is not 
                specified, then the current connection is used.</para>
                <para>If you use the current connection for reference and target,
                then you should prefix the table names with schema/user or
                use the <literal>-referenceschema</literal> and 
                <literal>-targetschema</literal> parameters.</para>
                </entry>
            </row>
            <row>
              <entry><para>-file</para></entry>
              <entry><para>The filename of the output file. If this 
              is not supplied the output will be written to the message area</para></entry>
            </row>
            
            <row>
                <entry><para>-referencetables</para></entry>
                <entry><para>A (comma separated) list of tables that are the reference 
                tables, to be checked. 
                </para></entry>
            </row>
            <row>
                <entry><para>-targettables</para></entry>
                <entry><para>A (comma separated) list of tables in the target
                connection to be compared to the source tables. The tables 
                are "matched" by their position in the list. The first table in the
                <literal>-sourcetables</literal> parameter is compared to the 
                first table in the <literal>-targettables</literal> parameter. And so
                on. Using this parameter you can compare tables that do not have the
                same name.</para>
                <para>If you omit this parameter, then all tables from the 
                target connection with the same names as those listed in 
                <literal>-sourcetables</literal> are compared.
                </para>
                <para>If you omit both parameters, then all tables that the 
                user can access are retrieved from the source connection 
                and compared to the tables with the same name in the target
                connection.
                </para>
                </entry>
            </row>
            <row>
                <entry><para>-referenceschema</para></entry>
                <entry><para>
                Compare all tables from the specified schema (user)
                </para></entry>
            </row>
            <row>
                <entry><para>-targetschema</para></entry>
                <entry><para>A schema in the target
                connection to be compared to the tables from the reference schema.
                </para>
                </entry>
            </row>
            
            <row>
                <entry><para>-namespace</para></entry>
                <entry><para>The namespace to be used for the XML tags. By default no
                namespace is used. If you supply a value for this e.g. <literal>wb</literal> the tag <literal>&lt;schema-report&gt;
                </literal> would be written as <literal>&lt;wb:modify-table&gt;</literal>
                </para></entry>
            </row>
            <row>
                <entry><para>-encoding</para></entry>
                <entry><para>The encoding to be used for the XML file. The 
                default is UTF-8
                </para></entry>
            </row>
          </tbody>
        </tgroup>
     </informaltable>
    
   </section>

    <section id="command-enableout" xreflabel="ENABLEOUT">
      <title>ENABLEOUT</title>

      <para>This command enables the <literal>DBMS_OUTPUT</literal> package when connected to
      an Oracle database. On other systems this command does nothing. After
      the <literal>DBMS_OUTPUT</literal> package is enabled, any message written with
      dbms_output.put_line() are displayed in the message pane after
      executing a SQL statement. It is equivalent to calling the
      dbms_output.enable() procedure.</para>

      <para>The <literal>DBMS_OUTPUT</literal> package can be enabled automatically when a
      connection is established. See <xref linkend="options-enable-out"/></para>
    </section>

    <section id="command-disableout">
      <title>DISABLEOUT</title>

      <para>This disables the <literal>DBMS_OUTPUT</literal> package for an Oracle database.
      This is equivalent to calling dbms_output.disable() procedure.</para>
    </section>
    
    <section id="command-wbfeedback">
      <title>WBFEEDBACK</title>

      <para>Normally &wb-productname; prints the results for each statement
      into the message panel. As this feedback can slow down the execution
      of large scripts, you can disable the feedback using the <literal>WBFEEDBAK</literal>
      command. When <literal>WBFEEDBACK OFF</literal> is executed, only a summary of the
      number of executed statements will be displayed, once the script execution has
            finished. This is the same behaviour as selecting "Consolidate script log" in the
            options window. The only difference is, that the setting through <literal>WBFEEDBACK</literal>
            is temporary and does not affect the global setting.
      </para>
    </section>

    <section id="command-vardef">
      <title>WBVARDEF</title>

      <para>This defines an internal variable which is used for variable substitution during
      SQL execution. Details can be found in the chapter <xref linkend="using-variables"/>.
      </para>
      <para>The syntax for defining a variable is: <literal>WBVARDEF variable=value</literal></para>
      <para>The variable definition can also be read from a file. The file should list 
      each variable definition on one line (this is the format of a normal Java properties 
      file). Lines beginning with a <literal>#</literal> sign are ignored.
      The syntax is <literal>WBVARDEF -file=&lt;filename&gt;</literal>
      </para>
      <para>You can also specify a file when starting &wb-productname; with the 
      parameter <literal>-vardef=&lt;filename&gt;</literal>.
      For details see see <link linkend="vardef-commandline">Reading variables from a file</link>.
      </para>
    </section>
    
    <section id="command-vardelete">
      <title>WBVARDELETE</title>

      <para>This removes an internal variable from the variable list.
       Details can be found in the chapter <xref linkend="using-variables"/>.
      </para>
    </section>

    <section id="command-varlist">
      <title>WBLISTVAR</title>

      <para>This list all defined variables from the variable list.
       Details can be found in the chapter <xref linkend="using-variables"/>.
      </para>
    </section>

    <section id="command-wbinclude">
      <title>WBINCLUDE (@)</title>
      <para>
         With the <literal>WBINCLUDE</literal> command you run SQL scripts without
         actually loading them into the editor, or call other scripts from within
         a script. The format of the command is <literal>WBINCLUDE filename;</literal>.
         The command can be abbreviated using the @ sign: <literal>@filename;</literal> is equivalent
         to <literal>WBINCLUDE filename;</literal>. The script that is run in this way may also include
         other scripts.
      </para>
      <para>There is also a "long" version of the command where you can supply
          additional parameters. When using the "long" version, the filename
          needs to be passed as a parameter as well.
      </para>
      <para>The command supports the following parameters:</para>

      <informaltable frame="all">
        <tgroup cols="2" align="left">
          <colspec colname="c1" colwidth="4cm" />
          <colspec colname="c2" />
            <thead>
              <row>
                <entry>Parameter</entry>
                <entry>Description</entry>
              </row>
            </thead>

          <tbody valign="top">
            <row>
              <entry><para>-file</para></entry>
              <entry><para>The filename of the file to be included.</para></entry>
            </row>
            <row>
                <entry><para>-continueOnError</para></entry>
                <entry><para>Defines the behaviour if an error occurs in one of the statements.
                If this is set to <literal>true</literal> then script execution will continue
                even if one statement fails. If set to <literal>false</literal> script execution
                will be halted on the first error. The default value is <literal>true</literal>
                </para></entry>
            </row>
            <row>
                <entry><para>-delimiter</para></entry>
                <entry><para>If the script uses a different delimiter then the semicolon
                then the delimiter needs to be defined with this parameter. The automatic 
                detection of the usage of the alternate delimiter does not work in this
                case as the file might not be read into memory completely.
                </para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      
      <para>Execute <literal>my_script.sql</literal></para>
      <programlisting>@my_script.sql;</programlisting>
      <para>Execute <literal>my_script.sql</literal> but abort on the first error</para>
      <programlisting>wbinclude -file="my_script.sql" -continueOnError=false;</programlisting>
    </section>

</section>