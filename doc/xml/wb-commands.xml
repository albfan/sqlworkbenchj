
<section id="wb-commands">
  <title>Other &wb-productname; specific commands</title>
  
	<para>
		In addtion to the <link linkend="command-export">WbExport</link>, 
		<link linkend="command-import">WbImport</link> and <link linkend="command-import">WbCopy</link>
		commands, &wb-productname; implements a set of additional SQL commands that are not part
		of the SQL standard. These commands can be used like any other SQL command
		(such as <literal>UPDATE</literal> inside &wb-productname;, i.e. inside the editor
		or as part of a SQL script that is run through &wb-productname; in <link linkend="using-scripting">batch mode</link>.
	</para>
	
	<para>
		As those commands are implemented by &wb-productname; you will not be able to 
		use them when running your SQL scripts using a different client program 
		(e.g. <literal>psql</literal>, SQL*Plus or <literal>phpmyadmin</literal>.
	</para>
	
  <section id="command-schema-report">
    <title>Create a report of the database objects - WbReport</title>
    
    <para>
      Creates an XML report of selected tables. This report could be used
      to generate an HTML documentation of the database (e.g. using the <link linkend="command-xslt">XSLT</link>
      command). This report can also be generated from within the <link linkend="dbexplorer">Database Object Explorer</link>
    </para>
		
    <para>
      The resulting XML file can  be transformed into a HTML documentation of your database schema.
      Sample stylesheets can be downloaded from   <ulink url="http://www.sql-workbench.net/xstl.html"/>.
      If you have XSLT stylsheets that you would like to share, please send them to
      <email>support@sql-workbench.net</email>.
    </para>
    
    <note><para>
      To see table and column comments with an Oracle database, you need to
      <link linkend="oracle-enable-remarks">enable remarks reporting</link> for the JDBC
      driver, otherwise the driver will not return comments.
    </para></note>
    
    <para>The command supports the following parameters:</para>
    
    <informaltable frame="all">
      <tgroup cols="2" align="left">
			<colspec colname="c1" colwidth="4cm" />
			<colspec colname="c2" />
			<thead>
				<row>
					<entry>Parameter</entry>
					<entry>Description</entry>
				</row>
			</thead>
	
			<tbody valign="top">
				<row>
					<entry>-file</entry>
					<entry>The filename of the output file.</entry>
				</row>
				<row>
					<entry>-tables</entry>
					<entry>A (comma separated) list of tables to report. Default is
						all tables. If this parameter is specified <literal>-schemas</literal> is ignored.
						If you want to generate the report on tables from different users/schemas you have
						to use fully qualified names in the list (e.g. <literal>-tables=MY_USER.TABLE1,OTHER_USER.TABLE2</literal>)
						You can also specify wildcards in the table name: <literal>-table=CONTRACT_%</literal> will create
						an XML report for all tables that start with <literal>CONTRACT_</literal>
					</entry>
				</row>
				<row>
					<entry>-schemas</entry>
					<entry>A (comma separated) list of schemas to generate the report from.
						For each user/schema all tables are included in the report. e.g.
						<literal>-schemas=MY_USER,OTHER_USER</literal> would generate a report
						for all tables in the schemas <literal>MY_USER</literal> and <literal>OTHER_USER</literal>.
					</entry>
				</row>
				<row>
					<entry>-namespace</entry>
					<entry>The namespace to be used for the XML tags. By default no
						namespace is used. If you supply a value for this e.g. <literal>wb</literal> the tag <literal>&lt;schema-report&gt;
						</literal> would be written as <literal>&lt;wb:schema-report&gt;</literal>
					</entry>
				</row>
				<row>
					<entry>-includeTables</entry>
					<entry>Control the output of table information for the report. The default is
						<literal>true</literal>. Valid values are <literal>true</literal>, <literal>false</literal>.
					</entry>
				</row>
				<row>
					<entry>-includeTableGrants</entry>
					<entry>If tables are included in the output, the grants for each table can also be included with 
						this parameter. The default value is <literal>false</literal>.
					</entry>
				</row>
				<row>
					<entry>-includeProcedures</entry>
					<entry>Control the output of stored procedure information for the report. The default is
						<literal>false</literal>. Valid values are <literal>true</literal>, <literal>false</literal>.
					</entry>
				</row>
				<row>
					<entry>-includeSequences</entry>
					<entry>Control the output of sequence information for the report. The default is
						<literal>false</literal>. Valid values are <literal>true</literal>, <literal>false</literal>.
					</entry>
				</row>
				<row>
					<entry>-reportTitle</entry>
					<entry>
						Defines the title for the generated XML file. The specified title is written 
						into the tag <literal>&lt;report-title&gt;</literal> and can be used when 
						transforming the XML e.g. into a HTML file.
					</entry>
				</row>
				<row>
					<entry>-stylesheet</entry>
					<entry>Apply a XSLT transformation to the generated XML file.</entry>
				</row>
				<row>
					<entry>-xsltOutput</entry>
					<entry>The name of the generated output file when applying the XSLT transformation.</entry>
				</row>
			</tbody>
      </tgroup>
    </informaltable>
  </section>
  
  <section id="command-schema-diff">
    <title>Compare two database schemas - WbSchemaDiff</title>
		
    <para>The <literal>WbSchemaDiff</literal> analyzes two schemas (or a list of tables)
      and outputs the differences between those schemas as an XML file. The XML file
      describes the changes that need to be applied to the target schema to have
      the same structure as the reference schema, e.g. modify column definitions,
      remove or add tables, remove or add indexes.
    </para>
		
    <para>
			The output is intended to be transformed using XSLT (e.g. with the
      <link linkend="command-xslt">XSLT Command</link>).
			
      Sample XSLT transformations can be found on the 
			<ulink url="http://www.sql-workbench.net/xslt.html">&wb-productname; homepage</ulink>
    </para>
		
    <para>The command supports the following parameters:</para>
    
    <informaltable frame="all">
      <tgroup cols="2" align="left">
			<colspec colname="c1" colwidth="4cm" />
			<colspec colname="c2" />
			<thead>
				<row>
					<entry>Parameter</entry>
					<entry>Description</entry>
				</row>
			</thead>
	
			<tbody valign="top">
				<row>
					<entry>-referenceProfile</entry>
					<entry>The name of the connection profile for the reference
						connection. If this is not specified, then the current connection is
					used.</entry>
				</row>
				<row>
					<entry>-referenceGroup</entry>
					<entry>If the name of your reference profile is not unique across 
						all profiles, you will need to specify the group in which the profile 
						is located with this parameter.
					</entry>
				</row>
				<row>
					<entry>-targetProfile</entry>
					<entry>
						<para>
							The name of the connection profile for the target
							connection (the one that needs to be migrated). If this is not
							specified, then the current connection is used.
						</para>
						<para>
							If you use the current connection for reference and target,
							then you should prefix the table names with schema/user or
							use the <literal>-referenceschema</literal> and
							<literal>-targetschema</literal> parameters.
						</para>
					</entry>
				</row>

				<row>
					<entry>-targetGroup</entry>
					<entry>
						If the name of your target profile is not unique across 
						all profiles, you will need to specify the group in which the profile 
						is located with this parameter.
					</entry>
				</row>

				<row>
					<entry>-file</entry>
					<entry>The filename of the output file. If this
					is not supplied the output will be written to the message area</entry>
				</row>

				<row>
					<entry>-referenceTables</entry>
					<entry>A (comma separated) list of tables that are the reference
						tables, to be checked.
					</entry>
				</row>

				<row>
					<entry>-targetTables</entry>
					<entry>
						<para>
							A (comma separated) list of tables in the target
							connection to be compared to the source tables. The tables
							are "matched" by their position in the list. The first table in the
							<literal>-referenceTables</literal> parameter is compared to the
							first table in the <literal>-targetTables</literal> parameter, and so
							on. Using this parameter you can compare tables that do not have the
							same name.
						</para>
						<para>
							If you omit this parameter, then all tables from the
							target connection with the same names as those listed in
							<literal>-referenceTables</literal> are compared.
						</para>
						<para>
							If you omit both parameters, then all tables that the
							user can access are retrieved from the source connection
							and compared to the tables with the same name in the target
							connection.
						</para>
					</entry>
				</row>

				<row>
					<entry>-referenceSchema</entry>
					<entry>
						Compare all tables from the specified schema (user)
					</entry>
				</row>

				<row>
					<entry>-targetSchema</entry>
					<entry>
						A schema in the target connection to be compared to the tables from the reference schema.
					</entry>
				</row>

				<row>
					<entry>-namespace</entry>
					<entry>The namespace to be used for the XML tags. By default no
						namespace is used. If you supply a value for this e.g. <literal>wb</literal> the tag <literal>&lt;schema-report&gt;
						</literal> would be written as <literal>&lt;wb:modify-table&gt;</literal>
					</entry>
				</row>

				<row>
					<entry>-encoding</entry>
					<entry>The encoding to be used for the XML file. The default is UTF-8</entry>
				</row>

				<row>
					<entry>-includePrimaryKeys</entry>
					<entry>Select whether primary key constraint definitions should be compared as well.
						The default is <literal>true</literal>.
						Valid values are <literal>true</literal> or <literal>false</literal>.
					</entry>
				</row>

				<row>
					<entry>-includeForeignKeys</entry>
					<entry>Select whether foreign key constraint definitions should be compared as well.
						The default is <literal>true</literal>.
						Valid values are <literal>true</literal> or <literal>false</literal>.
					</entry>
				</row>

				<row>
					<entry>-includeTableGrants</entry>
					<entry>Select whether table grants should be compared as well.
						The default is <literal>false</literal>.
					</entry>
				</row>

				<row>
					<entry>-includeConstraints</entry>
					<entry>
						<para>
							Select whether table and column (check) constraints
							should be compared as well. &wb-productname; compares the constraint
							definition (SQL) as stored in the database. 
						</para>
						<para>
							The default is to compare table constraints (<literal>true</literal>)
							Valid values are <literal>true</literal> or <literal>false</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-useConstraintNames</entry>
					<entry>
						<para>
							When including check constraints this parameter controls whether constraints
							should be matched by name, or only by their expression. If comparing by names
							is enabled, the diff output will contain elements for constraint modification
							otherwise only drop and add entries will be available.
						</para>
						<para>
							The default is to compare by names(<literal>true</literal>)
							Valid values are <literal>true</literal> or <literal>false</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-includeViews</entry>
					<entry>
						<para>
							Select whether views should also be compared. When comparing
							views, the source as it is stored in the DBMS is compared. This comparison
							is case-sensitiv, which means <literal>SELECT * FROM foo;</literal> will be
							reported as a difference to <literal>select * from foo;</literal> even
							if they are logically the same. A comparison across different DBMS will also not
							work properly!
						</para>
						<para>
							The default is <literal>true</literal>
							Valid values are <literal>true</literal> or <literal>false</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-includeProcedures</entry>
					<entry>
						<para>
							Select whether stored procedures should also be compared. When comparing
							procedures the source as it is stored in the DBMS is compared. This comparison
							is case-sensitiv. A comparison across different DBMS will also not work!
						</para>
						<para>
							The default is <literal>false</literal>
							Valid values are <literal>true</literal> or <literal>false</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-includeIndex</entry>
					<entry>
						Select whether indexes should be compared as well.  The default
						is to not compare index definitions.
						Valid values are <literal>true</literal> or <literal>false</literal>.
					</entry>
				</row>

				<row>
					<entry>-includeSequences</entry>
					<entry>
						Select whether sequences should be compared as well. The default is 
						to not compare sequences. Valid values are <literal>true</literal>, <literal>false</literal>.
					</entry>
				</row>

				<row>
					<entry>-useJdbcTypes</entry>
					<entry>
						<para>
							Define whether to compare the DBMS specific data types, or 
							the JDBC data type returned by the driver. When comparing 
							tables from two different DBMS it is recommended to use
							<literal>-useJdbcType=true</literal> as this will make the 
							comparison a bit more DBMS-independent. When comparing e.g. 
							Oracle vs. PostgreSQL a column defined as 
							<literal>VARCHAR2(100)</literal> in Oracle would be reported as beeing different
							to a <literal>VARCHAR(100)</literal> column in PostgreSQL which is not really true
							As both drivers ropert the column as java.sql.Types.VARCHAR, 
							they would be considered as identical when using <literal>-useJdbcType=true</literal>.
						</para>
						<para>
							Valid values are <literal>true</literal> or <literal>false</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-stylesheet</entry>
					<entry>Apply a XSLT transformation to the generated XML file.</entry>
				</row>
				<row>
					<entry>-xsltOutput</entry>
					<entry>The name of the generated output file when applying the XSLT transformation.</entry>
				</row>
				
			</tbody>
      </tgroup>
    </informaltable>
    
  </section>
  
	<section id="command-data-diff">

		<title>Compare data across databases - WbDataDiff</title>
		
		<para>
			The <literal>WbDataDiff</literal> command can be used to generate SQL scripts
			that update a target database such that the data is identical to a reference 
			database. This is similar to the <literal>WbSchemaDiff</literal> but compares 
			the actual data in the tables rather than the table structure.
		</para>
		<para>
			For each table the command will create up to three script files, depending on 
			the needed statements to migrate the data. One file for <literal>UPDATE</literal> statements, 
			one file for <literal>INSERT</literal> statements and one file for <literal>DELETE</literal>
			statements (if <literal>-includeDelete=true</literal> is specified)
		</para>
		
		<note><para>
			As this command needs to read every row from the reference and the target 
			table, processing large tables can take quite some time, especially if <literal>DELETE</literal>
			statements should also be generated.
		</para></note>
		
		<para>
			<literal>WbDataDiff</literal> requires that all involved tables have a primary key 
			defined. If a table does not have a primary key, <literal>WbDataDiff</literal> will 
			stop the processing.
		</para>
		
		<para>
			To improve performance (a bit), the rows are retrieved in chunks from the 
			target table by dynamically constructing a WHERE clause for the rows
			that were retrieved from the reference table. The chunk size 
			can be controlled using the property <literal>workbench.sql.sync.chunksize</literal>
			The chunk size defaults to 25. This is a conservative setting to avoid
			problems with long SQL statements when processing tables that have 
			a PK with multiple columns.	If you know that your primary keys
			consist only of a single column and the values won't be too long, you 
			can increase the chunk size, possibly increasing the performace when 
			generating the SQL statements. As most DBMS have a limit on the length
			of a single SQL statement, be careful when setting the chunksize too high.
			The same chunk size is applied when generating <literal>DELETE</literal> 
			statements by the <link linkend="command-copy"><literal>WbCopy</literal></link> command, 
			when <link linkend="copy-sync-delete">syncDelete</link>	mode is enabled.
		</para>
		
		<para>
			The command supports the following parameters:
		</para>
		
    <informaltable frame="all">
      <tgroup cols="2" align="left">
			<colspec colname="c1" colwidth="4cm" />
			<colspec colname="c2" />
			<thead>
				<row>
					<entry>Parameter</entry>
					<entry>Description</entry>
				</row>
			</thead>
	
			<tbody valign="top">
				<row>
					<entry>-referenceProfile</entry>
					<entry>
						The name of the connection profile for the reference connection. 
						If this is not specified, then the current connection is used.
					</entry>
				</row>
				<row>
					<entry>-referenceGroup</entry>
					<entry>
						If the name of your reference profile is not unique across 
						all profiles, you will need to specify the group in which the profile 
						is located with this parameter. If the profile's name is unique
						you can omit this parameter
					</entry>
				</row>
				<row>
					<entry>-targetProfile</entry>
					<entry>
						<para>
							The name of the connection profile for the target
							connection (the one that needs to be migrated). If this is not
							specified, then the current connection is used.
						</para>
						<para>
							If you use the current connection for reference and target,
							then you should prefix the table names with schema/user or
							use the <literal>-referenceschema</literal> and
							<literal>-targetschema</literal> parameters.
						</para>
					</entry>
				</row>

				<row>
					<entry>-targetGroup</entry>
					<entry>
						If the name of your target profile is not unique across 
						all profiles, you will need to specify the group in which the profile 
						is located with this parameter.
					</entry>
				</row>

				<row>
					<entry>-file</entry>
					<entry>
						The filename of the main script file. The command creates two 
						scripts per table. One script named <literal>update_&lt;tablename&gt;.sql</literal>
						that contains all needed <literal>UPDATE</literal> or <literal>INSERT</literal>
						statements. The second script is named <literal>delete_&lt;tablename&gt;.sql</literal>
						and will contain all <literal>DELETE</literal> statements for the target table.
						The main script merely calls (using <link linkend="command-wbinclude">WbInclude</link>)
						the generated scripts for each table.
					</entry>
				</row>

				<row>
					<entry>-referenceTables</entry>
					<entry>
						A (comma separated) list of tables that are the reference
						tables, to be checked. You can specify the table with wildcards, 
						e.g. <literal>-referenceTables=P%</literal> to compare all tables
						that start with the letter <literal>P</literal>.
					</entry>
				</row>

				<row>
					<entry>-targetTables</entry>
					<entry>
						<para>
							A (comma separated) list of tables in the target
							connection to be compared to the source tables. The tables
							are "matched" by their position in the list. The first table in the
							<literal>-referenceTables</literal> parameter is compared to the
							first table in the <literal>-targetTables</literal> parameter, and so
							on. Using this parameter you can compare tables that do not have the
							same name.
						</para>
						<para>
							If you omit this parameter, then all tables from the
							target connection with the same names as those listed in
							<literal>-referenceTables</literal> are compared.
						</para>
						<para>
							If you omit both parameters, then all tables that the
							user can access are retrieved from the source connection
							and compared to the tables with the same name in the target
							connection.
						</para>
					</entry>
				</row>

				<row>
					<entry>-referenceSchema</entry>
					<entry>
						Compare all tables from the specified schema (user)
					</entry>
				</row>

				<row>
					<entry>-targetSchema</entry>
					<entry>
						A schema in the target connection to be compared to the tables from the reference schema.
					</entry>
				</row>

				<row>
					<entry>-checkDependencies</entry>
					
					<entry>
						<para>Valid values are <literal>true</literal>, <literal>false</literal>.</para>
						<para>
							Sorts the generated scripts in order to respect foreign key dependencies
							for deleting and inserting rows. 
						</para>
						<para>
							The default is <literal>true</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-includeDelete</entry>
					<entry>
						<para>Valid values are <literal>true</literal>, <literal>false</literal>.</para>
						<para>
							Generates <literal>DELETE</literal> statements for rows that are present
							in the target table, but not in the reference table. The default is <literal>false</literal>.
						</para>
						<para>
							The default is <literal>false</literal>.
						</para>
					</entry>
				</row>

				<row>
					<entry>-encoding</entry>
					<entry>
						The encoding to be used for the SQL scripts. The default depends
						on your operating system. It will be displayed when you run 
						<literal>WbDataDiff</literal> without any parameters. You can overwrite
						the platform default with the property <literal>workbench.encoding</literal>
						in the file <literal>workbench.settings</literal>
					</entry>
				</row>

				<row>
					<entry>-sqlDateLiterals</entry>
					<entry>
						<para>Valid values: <literal>jdbc</literal>, <literal>ansi</literal>, <literal>dbms</literal>, <literal>default</literal></para>
						<para>
							Controls the format in which the values of DATE, TIME and TIMESTAMP columns
							are written into the generated SQL statements. 
							For a detailed description of the possible values, please refer to the 
							<link linkend="export-sql-literal-formats">WbExport</link>
							command.
						</para>
					</entry>
				</row>

				<row>
					<entry>-ignoreColumns</entry>
					<entry>
						<para>
							With this parameter you can define a list of column names that should 
							not be considered when comparing data. You can e.g. exclude 
							columns that store the last access time of a row, or the 
							last update time if that should not be taken into account 
							when checking for changes.
						</para>
					</entry>
				</row>

				&progress-parameter;
					
			</tbody>
      </tgroup>
    </informaltable>
		
		<simplesect id="data-diff-examples">
			<title>WbDataDiff Examples</title>
			<para>
				Compare all tables between two connections, and write the output to the 
				file <literal>migrate_staging.sql</literal>, but do not generate 
				<literal>DELETE</literal> statements.
			</para>
<programlisting>WbDataDiff -referenceProfile="Production"
           -targetProfile="Staging"
           -file=migrate_staging.sql
           -includeDelete=false</programlisting>

			<para>
				Compare a list of matching tables between two databases and write the output to the 
				file <literal>migrate_staging.sql</literal> including <literal>DELETE</literal> statements.
			</para>
			
<programlisting>WbDataDiff -referenceProfile="Production"
           -targetProfile="Staging"
           -referenceTables=person,address,person_address
           -file=migrate_staging.sql
           -includeDelete=true</programlisting>
		
		<para>
			Compare three tables that are differently named in the target database and
			ignore all columns (regardless in which table they appear) that are named
			<literal>LAST_ACCESS</literal> or <literal>LAST_UPDATE</literal>
		</para>
<programlisting>WbDataDiff -referenceProfile="Production"
           -targetProfile="Staging"
           -referenceTables=person,address,person_address
           -targetTables=t_person,t_address,t_person_address
           -ignoreColumns=last_access,last_update
           -file=migrate_staging.sql
           -includeDelete=true</programlisting>
		</simplesect>
		
	</section>
	
  <section id="command-xslt">
    <title>Run an XSLT transformation - WbXslt</title>
    
    <para>Transforms an XML file via a XSLT stylesheet. This can be used to format
      XML input files into the correct format for &wb-productname; or to transform
    the output files that are generated by the various &wb-productname; commands.</para>
    <para>Parameters for the XSLT command:</para>
    <informaltable frame="all">
      <tgroup cols="2"  align="left">
	<colspec colname="c1" colwidth="4cm" />
	<colspec colname="c2" />
	<thead>
	  <row>
	    <entry>Parameter</entry>
	    <entry>Description</entry>
	  </row>
	</thead>
	
	<tbody valign="top">
	  <row>
	    <entry>-inputfile</entry>
	    <entry>The name of the XML source file.</entry>
	  </row>
	  <row>
	    <entry>-xsltoutput</entry>
	    <entry>The name of the generated output file.</entry>
	  </row>
	  <row>
	    <entry>-stylesheet</entry>
	    <entry>The name of the XSLT stylesheet to be used.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </section>
  
  <section id="command-vardef">
    <title>Define a script variable - WbVarDef</title>
    
    <para>This defines an internal variable which is used for variable substitution during
      SQL execution. Details can be found in the chapter <xref linkend="using-variables"/>.
    </para>
    <para>The syntax for defining a variable is: <literal>WbVarDef variable=value</literal></para>
    <para>The variable definition can also be read from a file. The file should list
      each variable definition on one line (this is the format of a normal Java properties
      file). Lines beginning with a <literal>#</literal> sign are ignored.
      The syntax is <literal>WBVARDEF -file=&lt;filename&gt;</literal>
    </para>
    <para>You can also specify a file when starting &wb-productname; with the
      parameter <literal>-vardef=filename.ext</literal>. When specifying a filename
      you can also define an encoding for the file using the <literal>-encoding</literal>
      switch. The specified file has to be a regular Java properties file.
      For details see see <link linkend="cmdline-vardef">Reading variables from a file</link>.
    </para>
  </section>
  
  <section id="command-vardelete">
    <title>Delete a script variable - WbVarDelete</title>
    
    <para>This removes an internal variable from the variable list.
      Details can be found in the chapter <xref linkend="using-variables"/>.
    </para>
  </section>
  
  <section id="command-varlist">
    <title>Show defined script variables - WbVarList</title>
    
    <para>This list all defined variables from the variable list.
      Details can be found in the chapter <xref linkend="using-variables"/>.
    </para>
  </section>
  
  <section id="command-wbconfirm">
    <title>Confirm script execution - WbConfirm</title>
    <para>
      The <literal>WbConfirm</literal> command pauses the execution of the
      current script and displays a message. You can then choose to stop
      the script or continue. The message can be supplied as a parameter of
      the command. If no message is supplied, a default message is
      displayed.
    </para>
    <para>
      This command can be used to prevent accidental execution of a script
      even if <link linkend="profile-confirm-updates">confirm updates</link> is not enabled.
    </para>
    <para>
      This command has no effect in batch mode.
    </para>
  </section>
  
  <!--
		<section id="command-wbcall">
			<title>Run a stored procedure with OUT parameters - WbCall</title>
			<para>
				
			</para>
		</section>
		-->
		
  <section id="command-wbinclude">
    <title>Execute a SQL script - WbInclude (@)</title>
    <para>
      With the <literal>WbInclude</literal> command you run SQL scripts without
      actually loading them into the editor, or call other scripts from within
      a script. The format of the command is <literal>WbInclude -file=filename;</literal>.
      For DBMS other then MS SQL, the command can be abbreviated using the @ sign: <literal>@filename;</literal>
      is equivalent to <literal>WbInclude -file=filename;</literal>.
      The called script way may also include other scripts. Relative filens (e.g. as parameters 
      for &wb-productname; commands) in the script are always resolved to the directory
      where the script is located, not the current directory of the application.
    </para>
    <para>
      The reason for excluding MS SQL is, that when creating stored procedures in MS SQL, the procedure
      parameters are identified using the @ sign, thus &wb-productname; would interpret the lines
      with the variable definition as the WbInclude command. If you want to use the @ command
      with MS SQL, you can <link linkend="options-enable-shortinclude">configure</link> this in your
      <literal>workbench.settings</literal> configuration file.
    </para>
    <note><para>
	If the included SQL script contains <literal>SELECT</literal> queries, the result
	of those queries will <emphasis role="bold">not</emphasis> be displayed in the GUI
    </para></note>
    <para>The long version of the command accepts additional parameters.
      When using the long version, the filename needs to be passed as a parameter as well.
    </para>
    <para>
      Only files up to a <link linkend="options-max-script-size">certain size</link> will be read into memory. Files exceeding
      this size will be processes statement by statement. In this case the automatic
      detection of the <link linkend="alternate-delimiter-usage">alternate delimiter</link> will
      not work. If your scripts exceed the maximum size and do use the alternate delimiter
      you will have to use the "long" version so that you can specify the actual
      delimiter used in your script.
    </para>
    <para>The command supports the following parameters:</para>
    
    <informaltable frame="all">
      <tgroup cols="2" align="left">
	<colspec colname="c1" colwidth="4cm" />
	<colspec colname="c2" />
	<thead>
	  <row>
	    <entry>Parameter</entry>
	    <entry>Description</entry>
	  </row>
	</thead>
	
	<tbody valign="top">
	  <row>
	    <entry>-file</entry>
	    <entry>The filename of the file to be included.</entry>
	  </row>
	  
	  <row>
	    <entry>-continueOnError</entry>
	    <entry>
	      Defines the behaviour if an error occurs in one of the statements.
	      If this is set to <literal>true</literal> then script execution will continue
	      even if one statement fails. If set to <literal>false</literal> script execution
	      will be halted on the first error. The default value is <literal>false</literal>
	    </entry>
	  </row>
	  
	  <row>
	    <entry>-delimiter</entry>
	    <entry>
	      Specify the delimiter that is used in the script. This defaults 
	      to <literal>;</literal>. If you want to define a delimiter that
	      will only be recognized when it's the only text in a line, append <literal>:nl</literal>
	      to the value, e.g.: <literal>-delimiter=/:nl</literal>
	    </entry>
	  </row>
	  
	  <row>
	    <entry>-encoding</entry>
	    <entry>
				Specify the encoding of the input file. If no encoding is specified, 
				the default encoding for the current platform (operating system) is used.
			</entry>
	  </row>
	  
	  <row>
	    <entry>-verbose</entry>
	    <entry>Controls the logging level of the executed commands. <literal>-verbose=true</literal>
	      has the same effect as adding a <literal>WbFeedback on</literal> inside
	      the called script. <literal>-verbose=false</literal> has the same effect as adding 
	      the statement <literal>WbFeedback off</literal> to the called script.</entry>
	  </row>
	  
	</tbody>
      </tgroup>
    </informaltable>
    
    <para>Execute <literal>my_script.sql</literal></para>
    <programlisting>@my_script.sql;</programlisting>
    <para>Execute <literal>my_script.sql</literal> but abort on the first error</para>
    <programlisting>wbinclude -file="my_script.sql" -continueOnError=false;</programlisting>
  </section>
  
	<section id="pk-handling">
		<title>Handling tables or updateable views without primary keys</title>
		
		<section id="command-define-pk">
			<title>Define primary key columns - WbDefinePK</title>
			<para>
				To be able to directly edit data in the result set (grid) &wb-productname; needs
				a primary key on the underlying table. In some cases these primary keys are not present or
				cannot be retrieved from the database (e.g. when using updateable views).
				To still be able to automatically update a result based on those tables (without always
				manually defining the primary key) you can manually define a primary
				key using the <literal>WbDefinePk</literal> command.
			</para>
			<para>
				Assuming you have an updateable view called <literal>v_person</literal> where
				the primary key is the column <literal>person_id</literal>. When you simply do a
				<literal>SELECT * FROM v_person</literal>, &wb-productname; will prompt you for the
				primary key when you try to save changes to the data. If you run
			</para>

			<programlisting>WbDefinePk v_person=person_id</programlisting>
			<para>
				before retrieving the result, &wb-productname; will automatically
				use the <literal>person_id</literal> as the primary key (just as if this
				information had been retrieved from the database).
			</para>
			<para>To delete a definition simply call the command with an empty column list:</para>
			<programlisting>WbDefinePk v_person=</programlisting>
			<para>
				If you want to define certain mappings permanently, this can be done using
				a mapping file that is specified in the <link linkend="options-pkmapping">configuration file</link>.
				The file specified has to be a text file with each line containing one
				primary key definition in the same format as passed to this command. The global mapping will
				automatically be saved when you exit the application if a filename has been defined.
				If no file is defined, then all PK mappings that you define are lost when
				exiting the application (unless you explicitely save them using
				<link linkend="command-save-pkmap">WbSavePkMap</link>
			</para>

			<programlisting>v_person=person_id
v_data=id1,id2</programlisting>

			<para>
				will define a primary key for the view <literal>v_person</literal> and one for
				the view <literal>v_data</literal>. The definitions stored in that file can
				be overwritten using the <literal>WbDefinePk</literal> command, but those changes
				won't be saved to the file. This file will be read for all database connections and
				is not profile specific. If you have conflicting primary key definitions for
				different databases, you'll need to execute the <literal>WbDefinePk</literal> command
				each time, rather then specifying the keys in the mapping file.
			</para>

			<para>
				When you define the key columns for a table through the GUI, you have the option
				to remember the defined mapping. If this option is checked, then that mapping
				will be added to the global map (just as if you had executed <literal>WbDefinePk</literal>
				manually.
			</para>
			<note><para>
		The mappings will be stored with lowercase table names internally, regardless how you specify them.
			</para></note>

		</section>

		<section id="command-list-pk">
			<title>List defined primary key columns - WbListPKDef</title>
			<para>To view the currently defined primary keys, execute the command
			<literal>WbListPkDef</literal>.</para>
		</section>

		<section id="command-load-pkmap">
			<title>Load primary key mappings - WbLoadPKMap</title>
			<para>
				To load the additional primary key definitions from a file, you can
				use the the <literal>WbLoadPKMap</literal> command. If a filename is defined
				in the <link linkend="options-pkmapping">configuration file</link> then that
				file is loaded. Alternatively if no file is configured, or if you want to
				load a different file, you can specify the filename using the <literal>-file</literal>
				parameter.
			</para>
		</section>

		<section id="command-save-pkmap">
			<title>Save primary key mappings - WbSavePKMap</title>
			<para>
				To save the current primary key definitions to a file, you can
				use the the <literal>WbSavePKMap</literal> command. If a filename is defined
				in the <link linkend="options-pkmapping">configuration file</link> then the
				definition is stored in that file. Alternatively if no file is configured, or if you want to
				store the current mapping into a different file, you can specify the filename
				using the <literal>-file</literal> parameter.
			</para>
		</section>
		
	</section>
	
  <section id="command-selectblob">
    <title>Extracting BLOB content - WbSelectBlob</title>
    <para>
			To save the contents of a <literal>BLOB</literal> or <literal>CLOB</literal> column
      into an external file the <literal>WbSelectBlob</literal> command can be used. Most DBMS
      support reading of <literal>CLOB</literal> (character data) columns directly, so depending
      on your DBMS (and JDBC driver) this command might only be needed for binary data.
    </para>
    <para>
			The syntax is very similar to the regular <literal>SELECT</literal> statement, an additional
      <literal>INTO</literal> keyword specifies the name of the external file into which the
      data should be written:
    </para>
    <programlisting>WbSelectBlob blob_column
INTO c:/temp/image.bmp
FROM theTable
WHERE id=42;</programlisting>
    <para>
      Even if you specify more then one column in the column list, &wb-productname; will only
      use the first column. If the SELECT returns more then one row, then one 
      outputfile will be created for each row. Additional files will be created with 
      a counter indicating the row number from the result. In the above
      example, image.bmp, image_1.bmp, image_3.bmp and so on, would be created.
    </para>
		<para>
			<literal>WbSelectBlob</literal> is intended for an ad-hoc retrieval of a single LOB column.
			If you need to extract the contents of several LOB rows and columns it is recommended to
			use the <link linkend="command-export">WbExport</link> command.
		</para>
    <para>
			You can also manipulate (save, view, upload) the contents of BLOB columns in a result set.
			Please refer to <xref linkend="blob-support"/> for details.
    </para>

  </section>
	
  <section id="command-wbfeedback">
    <title>Control feedback messages - WbFeedback</title>
    <para>
      Normally &wb-productname; prints the results for each statement
      into the message panel. As this feedback can slow down the execution
      of large scripts, you can disable the feedback using the <literal>WbFeedback</literal>
      command. When <literal>WbFeedback OFF</literal> is executed, only a summary of the
      number of executed statements will be displayed, once the script execution has
      finished. This is the same behaviour as selecting "Consolidate script log" in the
      options window. The only difference is, that the setting through <literal>WbFeedback</literal>
      is temporary and does not affect the global setting.
    </para>
  </section>
  
  <section id="command-set">
    <title>Setting connection properties - SET</title>
    <para>
      The <literal>SET</literal> command is available to enable you to run SQL scripts that are 
      designed to run with Oracle's SQL*Plus utility inside &wb-productname; as well.
      Most of the parameters of the <literal>SET</literal> are only valid inside 
      SQL*Plus, and thus for Oracle any error message resulting from executing a <literal>SET</literal>
      command will only be logged as a warning. For all other DBMS the command is passed
      directly to the server, except for the parameters described in this chapter (because
      they have an equivalent JDBC call that will be executed instead).
    </para>

    <section id="command-set-feedback">
      <title>FEEEDBACK</title>
      <para>
				<literal>SET feedback ON/OFF</literal> is equivalent to the <link linkend="command-wbfeedback">WbFeedback</link>
				command, but mimics the syntax of Oracle's SQL*Plus utility.
      </para>
    </section>
    
    <section id="command-set-serveroutput">
      <title>SERVEROUTPUT</title>
      <para>
				<literal>SET serveroutput on</literal> is equivalent to the <link linkend="command-dbms-output">ENABLEOUT</link>
				command and <literal>SET serveroutput off</literal> is equivalent to <link linkend="command-dbms-output">DISABLEOUT</link> command.
      </para>
    </section>
    
    <section id="command-set-autocommit">
      <title>AUTOCOMMIT</title>
      <para>
				With the command <literal>SET autocommit ON/OFF</literal> autocommit can be turned on or 
				off for the current connection. This is equivalent to setting the autocommit property
				in the <link linkend="profile-jdbc-properties">connection profile</link> or toggling 
				the state of the 
				<menuchoice><guimenu>SQL</guimenu><guimenuitem>Autocommit</guimenuitem></menuchoice>
				menu item.
      </para>
    </section>

  </section>
  
  <section id="command-desc">
    <title>Show table structure - DESCRIBE</title>
    
    <para>
			Describe shows the definition of the given table. It can be
			abbreviated with DESC. The command expects the table name as a parameter. 
			The output of the command will be several result tabs to show the table 
			structure, indexes and triggers (if present).
			If the "described" object is a view, the message tab will additionally contain
			the view source (if available).
		</para>
		<programlisting>DESC person;</programlisting>

		<para>
			If you want to show the structure of a table from a different user, you need
			to prefix the table name with the desired user <literal>DESCRIBE otheruser.person;</literal>
		</para>
		<note><para>
			Although the name of this command is identical to Oracle SQL*Plus' <literal>DESC</literal>
			command, this is a &wb-productname; specific implementation and works the same way on
			any supported DBMS.
		</para></note>
  </section>
  
  <section id="command-list">
    <title>List tables - WbList</title>
    
    <para>
			This command lists all available tables (including views and
      synonyms). This output is equivalent to the left part of the Database
      Object Explorer&#39;s Table tab.
    </para>

    <para>
			You can limit the displayed objects by either specifying a wildcard for the
			names to be retrieved: <literal>WbList P%</literal> will list all tables or
			views starting with the letter "P"
    </para>

    <para>
			The command supports two parameters to specify the tables and objects defined
			in a more detailed manner. If you want to limit the result by specifying a
			wildcard for the name <emphasis role="bold">and</emphasis> the object type,
			you have to use the parameter switches:
			<informaltable frame="all">
				<tgroup cols="2" align="left">
					<colspec colname="c1"  colwidth="2.5cm" />
					<colspec colname="c2"/>
					<thead>
						<row>
							<entry>Parameter</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody valign="top">
						<row>
							<entry>-objects</entry>
							<entry>
								<para>
									Select the objects to be returned using a wildcard name, e.g. <literal>-objects=P%</literal>
								</para>
							</entry>
						</row>
						<row>
							<entry>-types</entry>
							<entry>
								<para>
									Limit the result to specific object types, e.g. <literal>WbList -objects=V% -types=VIEW</literal>
									will return all views starting with the letter "V".
								</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</para>

  </section>
  
  <section id="command-listprocs">
    <title>List stored procedures - WbListProcs</title>
    
    <para>
			This command will list all stored procedures available to the
      current user. The output of this command is equivalent to the Database
			Explorer&apos;s Procedure tab.
		</para>
		<para>
			You can limit the list by supplying a wildcard search for the name, e.g.:
			<programlisting>WbListProcs public.p%</programlisting>
		</para>
  </section>

  <section id="command-listtriggers">
    <title>List triggers - WbListTriggers</title>

    <para>
			This command will list all stored triggers available to the
      current user. The output of this command is equivalent to the Database
			Explorer&apos;s Triggers tab (if enabled)
		</para>
  </section>

  <section id="command-procsource">
    <title>Show the source of a stored procedures - WbProcSource</title>

    <para>
			This command will show the source for a single stored procedure (if the
			current DBMS is supported by &wb-productname;). The name of the procedure
			is given as an argument to the command:
			<programlisting>WbProcSource theAnswer</programlisting>
		</para>
  </section>

  <section id="command-listcat">
    <title>List catalogs - WbListCat</title>
    
    <para>Lists the available catalogs or databases. The output of this
      command depends on the underlying JDBC driver and DBMS. For MS SQL
      Server this lists the available databases (which then could be changed
    by USE &#60;dbname&#62;)</para>
    
    <para>
			For Oracle this command returns nothing (as Oracle does not
			implement the concept of catalogs)
		</para>
    <para>
			This command calls the JDBC driver&apos;s <literal>getCatalogs()</literal> method and will
      return its result. If on your database system this command does not display
      a list, it is most likely that your DBMS does not support catalogs (e.g. Oracle)
      or the driver does not implement this feature.
    </para>
  </section>

  <section id="command-connect">
    <title>Change the connection for a script - WbConnect</title>

    <para>
			With the <literal>WbConnect</literal> command, the connection for the script that is
			currently be exected can be changed.
		</para>
		
		<para>
			When this command is run in GUI mode, the connection is <emphasis role="bold">only</emphasis>
			changed for the remainder of the script execution. Therefor at least one other statement should be
			executed together with the <literal>WbConnect</literal> command. Either by running
			the complete script of the editor or selecting the <literal>WbConnect</literal> command
			together with other statements. Once the script has finished, the connection is closed 
			and the "global" connection (selected in the connect dialog) is active again. This also applies
			to scripts that are run in <link linkend="using-scripting">batch mode</link> or
			scripts that are started from within the console using
			<literal><link linkend="command-wbinclude">WbInclude</link></literal>.
		</para>

		<para>
			When this command is entered directly in the commandline of the 
			<link linkend="console-mode">console mode</link>, the current connection is closed and the
			new connection is kept open until the application ends, or a new connection is established
			using <literal>WbConnect</literal> on the commandline again.
		</para>

	  <para>
			The command supports the following parameters:
		</para>

		<informaltable frame="all">
			<tgroup cols="2">
				<colspec colname="c1" colwidth="3.6cm" />
				<colspec colname="c2" />
				<thead>
					<row>
						<entry>Parameter</entry>
						<entry>Description</entry>
					</row>
				</thead>

				<tbody valign="top">
					
				<row>
					<entry>-profile</entry>
					<entry>
						Defines the profile to connect to. If this parameter is specified
						all other parameters are ignored.
					</entry>
				</row>

				<!-- Create an empty line to distinguish between the -profile
				     parameter and the others -->
				<row>
					<entry rowsep="0" colsep="0"></entry>
					<entry rowsep="0" colsep="0"></entry>
				</row>

				<row>
					<entry rowsep="0" colsep="0">or</entry>
					<entry rowsep="0" colsep="0"></entry>
				</row>

				<row>
					<entry colsep="0"></entry>
					<entry colsep="0"></entry>
				</row>

					&common-connect-args;
				</tbody>
			</tgroup>
		</informaltable>

		<para>
			If none of the parameters is supplied when running the command, it is assumed that any value
			after <literal>WbConnect</literal> is the name of a connection profile, e.g.:
		</para>
		<programlisting>WbConnect production</programlisting>
		<para>
			will connect using the profile name <literal>production</literal>, and is equivalent to
		</para>
		<programlisting>WbConnect -profile=production</programlisting>
		
  </section>

  <section id="command-dbms-output" xreflabel="ENABLEOUT">
    <title>Using Oracle's DBMS_OUTPUT package</title>

    <para>
      To turn on support for Oracle's <literal>DBMS_OUTPUT</literal> package you have to use the
			(&wb-productname; specific) command <literal>ENABLEOUT</literal>.
		</para>
		<para>
			After running <literal>ENABLEOUT</literal> the <literal>DBMS_OUTPUT</literal> package is enabled,
			and any message written with <literal>dbms_output.put_line()</literal> is displayed in the message
			pane after executing a SQL statement. It is equivalent to calling the dbms_output.enable() procedure.
    </para>

    <para>
      You can control the buffer size of the <literal>DBMS_OUTPUT</literal> package by passing the
      desired buffer size as a parameter to the <literal>ENABLEOUT</literal> command:
			<literal>ENABLEOUT 32000;</literal>
    </para>

    <note><para>
	Due to a bug in Oracle's JDBC driver, you cannot retrieve columns with
	the <literal>LONG</literal> or <literal>LONG RAW</literal> data type if the <literal>DBMS_OUTPUT</literal>
	package is enabled.
	In order to be able to display these columns support for <literal>DBMS_OUTPUT</literal> has
	to be switched off.
    </para></note>

		<para>
			To disable the <literal>DBMS_OUTPUT</literal> package again, use the (&wb-productname; specific)
			command <literal>DISABLEOUT</literal>. This is equivalent to calling
			<literal>dbms_output.disable()</literal> procedure.
		</para>
  </section>


</section>